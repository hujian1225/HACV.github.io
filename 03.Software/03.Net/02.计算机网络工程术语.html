<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络工程术语 | HACV</title>
    <meta name="description" content="Personal Blog Website">
    <link rel="icon" href="/images/photo.jpg">
  <link rel="manifest" href="/images/photo.jpg">
  <link rel="apple-touch-icon" href="/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.0dbae9ec.css" as="style"><link rel="preload" href="/assets/js/app.dfedf38e.js" as="script"><link rel="preload" href="/assets/js/8.662933a2.js" as="script"><link rel="prefetch" href="/assets/js/10.8b1a8982.js"><link rel="prefetch" href="/assets/js/100.ec9f99f2.js"><link rel="prefetch" href="/assets/js/101.67a1fdb9.js"><link rel="prefetch" href="/assets/js/102.2004fcaf.js"><link rel="prefetch" href="/assets/js/103.7aba7002.js"><link rel="prefetch" href="/assets/js/104.04dab70f.js"><link rel="prefetch" href="/assets/js/105.cd8ca492.js"><link rel="prefetch" href="/assets/js/106.7a1b0dad.js"><link rel="prefetch" href="/assets/js/107.ee74dc03.js"><link rel="prefetch" href="/assets/js/108.c58b32e8.js"><link rel="prefetch" href="/assets/js/109.0cbaad86.js"><link rel="prefetch" href="/assets/js/11.fbedd4ab.js"><link rel="prefetch" href="/assets/js/110.79551bd5.js"><link rel="prefetch" href="/assets/js/111.caad64f2.js"><link rel="prefetch" href="/assets/js/112.129b6bbb.js"><link rel="prefetch" href="/assets/js/113.25ad326a.js"><link rel="prefetch" href="/assets/js/114.8ccc35d8.js"><link rel="prefetch" href="/assets/js/115.c2e36834.js"><link rel="prefetch" href="/assets/js/116.362713d5.js"><link rel="prefetch" href="/assets/js/117.a35e8800.js"><link rel="prefetch" href="/assets/js/118.92b18e51.js"><link rel="prefetch" href="/assets/js/119.fc80b0d5.js"><link rel="prefetch" href="/assets/js/12.5f12d1d3.js"><link rel="prefetch" href="/assets/js/120.6a80072f.js"><link rel="prefetch" href="/assets/js/121.b568dd2a.js"><link rel="prefetch" href="/assets/js/122.2ccc3fb3.js"><link rel="prefetch" href="/assets/js/13.9e06c992.js"><link rel="prefetch" href="/assets/js/14.f56fb8af.js"><link rel="prefetch" href="/assets/js/15.f1ac59f2.js"><link rel="prefetch" href="/assets/js/16.837f7e09.js"><link rel="prefetch" href="/assets/js/17.94456321.js"><link rel="prefetch" href="/assets/js/18.63333f8e.js"><link rel="prefetch" href="/assets/js/19.9904db71.js"><link rel="prefetch" href="/assets/js/2.ea6b5af2.js"><link rel="prefetch" href="/assets/js/20.9ae0451f.js"><link rel="prefetch" href="/assets/js/21.b5d6351d.js"><link rel="prefetch" href="/assets/js/22.936ef172.js"><link rel="prefetch" href="/assets/js/23.104e8047.js"><link rel="prefetch" href="/assets/js/24.7756c459.js"><link rel="prefetch" href="/assets/js/25.64d9c1a5.js"><link rel="prefetch" href="/assets/js/26.ff737304.js"><link rel="prefetch" href="/assets/js/27.06462ce2.js"><link rel="prefetch" href="/assets/js/28.2073048b.js"><link rel="prefetch" href="/assets/js/29.2312b487.js"><link rel="prefetch" href="/assets/js/3.c95a7970.js"><link rel="prefetch" href="/assets/js/30.9c735025.js"><link rel="prefetch" href="/assets/js/31.fbb98085.js"><link rel="prefetch" href="/assets/js/32.f681886c.js"><link rel="prefetch" href="/assets/js/33.57cf5845.js"><link rel="prefetch" href="/assets/js/34.a95571de.js"><link rel="prefetch" href="/assets/js/35.411f82e9.js"><link rel="prefetch" href="/assets/js/36.060a20ef.js"><link rel="prefetch" href="/assets/js/37.4c6cca71.js"><link rel="prefetch" href="/assets/js/38.e6489e66.js"><link rel="prefetch" href="/assets/js/39.de67de8f.js"><link rel="prefetch" href="/assets/js/4.aa8d39a3.js"><link rel="prefetch" href="/assets/js/40.12366dec.js"><link rel="prefetch" href="/assets/js/41.3d94a5b0.js"><link rel="prefetch" href="/assets/js/42.fab88fca.js"><link rel="prefetch" href="/assets/js/43.e11a28b7.js"><link rel="prefetch" href="/assets/js/44.b8e9dcc0.js"><link rel="prefetch" href="/assets/js/45.5428a31b.js"><link rel="prefetch" href="/assets/js/46.ac29f2cb.js"><link rel="prefetch" href="/assets/js/47.4abeadd1.js"><link rel="prefetch" href="/assets/js/48.0e22c8f3.js"><link rel="prefetch" href="/assets/js/49.23baf201.js"><link rel="prefetch" href="/assets/js/5.9d3a0c8d.js"><link rel="prefetch" href="/assets/js/50.4a40bd19.js"><link rel="prefetch" href="/assets/js/51.c8bf6dc1.js"><link rel="prefetch" href="/assets/js/52.a339cfe3.js"><link rel="prefetch" href="/assets/js/53.70f4f61f.js"><link rel="prefetch" href="/assets/js/54.4bca8b72.js"><link rel="prefetch" href="/assets/js/55.82380eb5.js"><link rel="prefetch" href="/assets/js/56.6022d655.js"><link rel="prefetch" href="/assets/js/57.967ee58c.js"><link rel="prefetch" href="/assets/js/58.f19e0f6f.js"><link rel="prefetch" href="/assets/js/59.c2f13d73.js"><link rel="prefetch" href="/assets/js/6.dca2ac60.js"><link rel="prefetch" href="/assets/js/60.4d992dd8.js"><link rel="prefetch" href="/assets/js/61.10294b62.js"><link rel="prefetch" href="/assets/js/62.bc6c987a.js"><link rel="prefetch" href="/assets/js/63.bda11615.js"><link rel="prefetch" href="/assets/js/64.e5ef35bf.js"><link rel="prefetch" href="/assets/js/65.54d50796.js"><link rel="prefetch" href="/assets/js/66.fe852bad.js"><link rel="prefetch" href="/assets/js/67.0bbd0d0b.js"><link rel="prefetch" href="/assets/js/68.d0079bd8.js"><link rel="prefetch" href="/assets/js/69.0a14c81c.js"><link rel="prefetch" href="/assets/js/7.feb09d70.js"><link rel="prefetch" href="/assets/js/70.9784e9c8.js"><link rel="prefetch" href="/assets/js/71.c81e2a24.js"><link rel="prefetch" href="/assets/js/72.23ca527a.js"><link rel="prefetch" href="/assets/js/73.9bcbe865.js"><link rel="prefetch" href="/assets/js/74.8ef2dc7a.js"><link rel="prefetch" href="/assets/js/75.ce545424.js"><link rel="prefetch" href="/assets/js/76.99bb0523.js"><link rel="prefetch" href="/assets/js/77.f077264e.js"><link rel="prefetch" href="/assets/js/78.6c4fe0ed.js"><link rel="prefetch" href="/assets/js/79.7b6f32de.js"><link rel="prefetch" href="/assets/js/80.5ea815d4.js"><link rel="prefetch" href="/assets/js/81.5695e3e6.js"><link rel="prefetch" href="/assets/js/82.0693d977.js"><link rel="prefetch" href="/assets/js/83.7e1a3f59.js"><link rel="prefetch" href="/assets/js/84.f0d79bb4.js"><link rel="prefetch" href="/assets/js/85.ddac540a.js"><link rel="prefetch" href="/assets/js/86.8f2ba248.js"><link rel="prefetch" href="/assets/js/87.acddd200.js"><link rel="prefetch" href="/assets/js/88.0d4e8032.js"><link rel="prefetch" href="/assets/js/89.89a1338d.js"><link rel="prefetch" href="/assets/js/9.d3ddfe3c.js"><link rel="prefetch" href="/assets/js/90.d5bf56d4.js"><link rel="prefetch" href="/assets/js/91.b75f1eae.js"><link rel="prefetch" href="/assets/js/92.3151cb77.js"><link rel="prefetch" href="/assets/js/93.0c4e1803.js"><link rel="prefetch" href="/assets/js/94.5c7c580f.js"><link rel="prefetch" href="/assets/js/95.50c70374.js"><link rel="prefetch" href="/assets/js/96.9811160c.js"><link rel="prefetch" href="/assets/js/97.25ea3a18.js"><link rel="prefetch" href="/assets/js/98.9c6339ef.js"><link rel="prefetch" href="/assets/js/99.4af52ad4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0dbae9ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">HACV</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">🎓Coding</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/00.Coding/TheBeautyOfProgramming/" class="nav-link">🔖编程之美题解</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/CodeWarehouse/" class="nav-link">🔖代码意识流</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">🚀语言</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/01.Language/Overview/" class="nav-link">🔖概述</a></li><li class="dropdown-item"><!----> <a href="/01.Language/C/" class="nav-link">⭐️C</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Cpp/" class="nav-link">🚀C++</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Java/" class="nav-link">☕️Java</a></li></ul></div></div><div class="nav-item"><a href="/02.Hardware/" class="nav-link">✔️硬件基础</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/03.Software/01.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></li><li class="dropdown-item"><!----> <a href="/03.Software/02.OS/" class="nav-link">💻操作系统</a></li><li class="dropdown-item"><!----> <a href="/03.Software/03.Net/" class="nav-link router-link-active">☁️计算机网络</a></li><li class="dropdown-item"><!----> <a href="/03.Software/04.SE/" class="nav-link">✅软件工程</a></li></ul></div></div><div class="nav-item"><a href="/04.Database/" class="nav-link">🎨数据库</a></div><div class="nav-item"><a href="/05.Engineer/" class="nav-link">🔖学术/工程</a></div><div class="nav-item"><a href="/06.Tools/" class="nav-link">⚙️工具</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">🎓Coding</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/00.Coding/TheBeautyOfProgramming/" class="nav-link">🔖编程之美题解</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/CodeWarehouse/" class="nav-link">🔖代码意识流</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">🚀语言</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/01.Language/Overview/" class="nav-link">🔖概述</a></li><li class="dropdown-item"><!----> <a href="/01.Language/C/" class="nav-link">⭐️C</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Cpp/" class="nav-link">🚀C++</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Java/" class="nav-link">☕️Java</a></li></ul></div></div><div class="nav-item"><a href="/02.Hardware/" class="nav-link">✔️硬件基础</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/03.Software/01.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></li><li class="dropdown-item"><!----> <a href="/03.Software/02.OS/" class="nav-link">💻操作系统</a></li><li class="dropdown-item"><!----> <a href="/03.Software/03.Net/" class="nav-link router-link-active">☁️计算机网络</a></li><li class="dropdown-item"><!----> <a href="/03.Software/04.SE/" class="nav-link">✅软件工程</a></li></ul></div></div><div class="nav-item"><a href="/04.Database/" class="nav-link">🎨数据库</a></div><div class="nav-item"><a href="/05.Engineer/" class="nav-link">🔖学术/工程</a></div><div class="nav-item"><a href="/06.Tools/" class="nav-link">⚙️工具</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>计算机网络工程术语</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#✅01-术语类辨析" class="sidebar-link">✅01.术语类辨析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_1-1-子网、局域网、网段的关系" class="sidebar-link">1.1.子网、局域网、网段的关系</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_1-2-《linux多线程服务器编程》的说明" class="sidebar-link">1.2.《Linux多线程服务器编程》的说明</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_1-3-公有ip和私有ip" class="sidebar-link">1.3.公有IP和私有IP</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_1-4-公有-私有ip（a、b、c类）" class="sidebar-link">1.4.公有/私有IP（A、B、C类）</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_1-5-单工-半双工-全双工" class="sidebar-link">1.5.单工-半双工-全双工</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_1-6-心跳包" class="sidebar-link">1.6.心跳包</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_1-7-乒乓包" class="sidebar-link">1.7.乒乓包</a></li></ul></li><li><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#✅概念辨析『重要』" class="sidebar-link">✅概念辨析『重要』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_01-链路层、网络接口层、数据链路层" class="sidebar-link">01.链路层、网络接口层、数据链路层</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_02-区分arp和rarp" class="sidebar-link">02.区分ARP和RARP</a></li></ul></li><li><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#参考资料" class="sidebar-link">参考资料</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#网络基础" class="sidebar-link">网络基础</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_01-基本概念" class="sidebar-link">01. 基本概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_1-1-协议" class="sidebar-link">1.1.协议</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_1-2-协议格式" class="sidebar-link">1.2.协议格式</a></li></ul></li><li><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_02-c-s和b-s" class="sidebar-link">02.C/S和B/S</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_2-1-c-s架构" class="sidebar-link">2.1.C/S架构</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_2-2-b-s架构" class="sidebar-link">2.2.B/S架构</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_2-3-总结" class="sidebar-link">2.3.总结</a></li></ul></li><li><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_03-tcp-ip4层模型和os" class="sidebar-link">03.TCP/IP4层模型和OS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_3-1-7层模型和tcp-ip4层对应方式" class="sidebar-link">3.1.7层模型和TCP/IP4层对应方式</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_3-2-计算机网络中的os『重要』" class="sidebar-link">3.2.计算机网络中的OS『重要』</a></li></ul></li><li><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_04-自底向上4层模型" class="sidebar-link">04.自底向上4层模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_4-1-以太网帧『网络接口层』" class="sidebar-link">4.1.以太网帧『网络接口层』</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_4-2-arp数据报『网络层』" class="sidebar-link">4.2.ARP数据报『网络层』</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_4-3-路由器寻址『网络层』" class="sidebar-link">4.3.路由器寻址『网络层』</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_4-3-ip段格式『网络层』" class="sidebar-link">4.3.IP段格式『网络层』</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_4-4-tcp-udp『传输层』" class="sidebar-link">4.4.TCP/UDP『传输层』</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_4-5-应用层没有固定格式『重要』" class="sidebar-link">4.5.应用层没有固定格式『重要』</a></li></ul></li><li><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_05-套接字（socket）" class="sidebar-link">05.套接字（Socket）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_1、nat『映射』" class="sidebar-link">1、NAT『映射』</a></li><li class="sidebar-sub-header"><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#_2、nat『穿透』" class="sidebar-link">2、NAT『穿透』</a></li></ul></li><li><a href="/03.Software/03.Net/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD.html#参考资料-2" class="sidebar-link">参考资料</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="计算机网络工程术语"><a href="#计算机网络工程术语" class="header-anchor">#</a> 计算机网络工程术语</h1> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>电路交换：物理链路
分组交换
时延
<span class="token number">3</span>种通信方式：单工通信、半双工通信、全双工通信
广播、单播、组播
点对点『网络层』
端对端『传输层』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-txt line-numbers-mode"><pre class="language-text"><code>计算机科学并非自然科学，显然我们无法改变物理规律或者数学规律，而计算机软件的世界却不一样。
只要我们愿意，我们就可以从零开始编写代码。而为什么我们写一个hello world的时候并不会从硬件操作开始写呢？因为我们可以站在巨人的肩膀上，省时省力。

所以，计算机软件世界中，你能够做什么，很大程度取决于你能够调用什么API。API是前人劳动的总结，就像“定理”或者“推论”，你甚至可以不知道API的实现具体做了什么，你只要知道什么时候可以用这条API，用了这条API后会有什么结果和副作用。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>参考自知乎：什么是<a href="https://zhuanlan.zhihu.com/p/145194248" target="_blank" rel="noopener noreferrer">API<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="✅01-术语类辨析"><a href="#✅01-术语类辨析" class="header-anchor">#</a> ✅01.术语类辨析</h2> <h3 id="_1-1-子网、局域网、网段的关系"><a href="#_1-1-子网、局域网、网段的关系" class="header-anchor">#</a> 1.1.子网、局域网、网段的关系</h3> <p>CSDN<a href="https://blog.csdn.net/jeffleo/article/details/54174835" target="_blank" rel="noopener noreferrer">解释<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li><p><strong>在不要求精确性的情况下，子网、局域网和网段可以理解为同一个意思，但是同一个局域网/同一个子网/同一个网段 和 同一个网络不是同一个概念</strong></p></li> <li><p>子网划分</p></li></ul> <blockquote><p><a href="https://blog.51cto.com/yuanbin/112029" target="_blank" rel="noopener noreferrer">参考文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（很不错）</p></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>例<span class="token number">1</span>：本例通过子网数来划分子网，未考虑主机数。
一家集团公司有<span class="token number">12</span>家子公司，每家子公司又有<span class="token number">4</span>个部门。上级给出一个『『『<span class="token number">172.16</span><span class="token punctuation">.</span><span class="token number">0.0</span><span class="token operator">/</span><span class="token number">16</span>的网段』』』（我疑惑的地方！！！），让给每家子公司以及子公司的部门分配网段。
思路：既然有<span class="token number">12</span>家子公司，那么就要划分<span class="token number">12</span>个『『『子网段』』』（或许这话更准？？），但是每家子公司又有<span class="token number">4</span>个部门，因此又要在每家子公司所属的网段中划分<span class="token number">4</span>个子网分配给各部门。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_1-2-《linux多线程服务器编程》的说明"><a href="#_1-2-《linux多线程服务器编程》的说明" class="header-anchor">#</a> 1.2.《Linux多线程服务器编程》的说明</h3> <ul><li>Q：TCP协议真的有所谓的“粘包问题”吗？</li> <li>《<a href="https://book.douban.com/subject/1828749/" target="_blank" rel="noopener noreferrer">Effective TCP/IP Programming<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》这本书属于专家经验总结类，初看时觉得收获很大，工作一段时间再看也能有新的发现。比如第6 条“TCP是一个字节流协议”，看过这一条就不会去研究所谓的“TCP粘包问题”。</li></ul> <blockquote><p><a href="http://www.52im.net/thread-2608-1-1.html" target="_blank" rel="noopener noreferrer">参考文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h3 id="_1-3-公有ip和私有ip"><a href="#_1-3-公有ip和私有ip" class="header-anchor">#</a> 1.3.公有IP和私有IP</h3> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>IP地址的分类？
IP地址的网络部分是由internet地址分配机构来统一分配的，这样可以保证IP的唯一性

『注意1』
IP地址中全为1的IP即255.255.255.255 它标示限制广播地址，如果将其作为数据包的目标地址可以理解为发送到所有网络的所有主机

『注意2』
IP地址全为0的IP即0.0.0.0 表示启动时的IP地址 含义尚未未分配的IP地址

『注意3』
127是用来进行本机测试的，除了127.255.255.255外，其他的127开头的地址都代表本机
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ul><li>公共地址</li></ul> <p>由 Inter NIC（Internet Network Information Center 因特网信息中心）负责。这些 IP 地址分配给注册并向Inter NIC提出申请的组织机构，<strong>公有 IP 全球唯一</strong>，通过它直接访问因特网（直接能上网）。公共IP地址是能够让两台电脑相互识别的数字。在连接互联网时，用户的电脑通常被ISP（互联网服务提供者）安排一个地址。</p> <ul><li>私有地址</li></ul> <p>属于非注册地址，专门为<strong>组织机构内部使用</strong>，也就是说，私有 IP 不能直接上网。在许多电脑或设备被电缆或无线相互连接时，就可以构成一个私有网络。尽管私有网络中的地址必需是唯一的，但<strong>不同网络</strong>可以使用相同的地址。我们办的宽带通过路由器接入，使用的IP地址就是私有IP地址，路由器的设备将数据利用私有IP地址在连接的电脑之间传输
原文链接：https://blog.csdn.net/sdd220/article/details/78337796</p> <h3 id="_1-4-公有-私有ip（a、b、c类）"><a href="#_1-4-公有-私有ip（a、b、c类）" class="header-anchor">#</a> 1.4.公有/私有IP（A、B、C类）</h3> <p>什么是a.b.c类地址？（zhihu）</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>[知乎](https://www.zhihu.com/question/302935308/answer/544123478)
作者：架在天国的陆
链接：https://www.zhihu.com/question/302935308/answer/544123478
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>1． A类IP地址一个A类IP地址由1字节的网络地址和3字节主机地址组成
<ul><li><strong>网络地址的最高位必须是“0”</strong>， 地址范围从<code>1.0.0.0</code>到<code>126.0.0.0</code></li> <li>可用的A类网络有126个，每个网络能容纳1亿多个主机。<strong>(中国有4个A类IPv4地址)</strong></li> <li>关于网络号：从0-127的说法，其实是可以理解的『但是』</li> <li>原因：</li> <li>『注意2』
IP地址全为0的IP即0.0.0.0 表示启动时的IP地址 含义尚未未分配的IP地址</li> <li>『注意3』
127是用来进行本机测试的，除了127.255.255.255外，其他的127开头的地址都代表本机</li> <li>所以，我们只算1-126的</li></ul></li> <li>2． B类IP地址一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成
<ul><li>网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255</li> <li>可用的B类网络有16382个，每个网络能容纳6万多个主机</li> <li><font style="background:yellow;">『其中，除去私有IP172.16.0.0~172.31.255.255这些私有B类IP，其他的是B类公有IP』</font></li></ul></li> <li>3． C类IP地址一个C类IP地址由3字节的网络地址和1字节的主机地址组成
<ul><li>网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255</li> <li>C类网络可达209万余个，每个网络能容纳254个主机。</li> <li>IP地址由4个字节组成(4*8=32 bit)，采用点分十进制标记法，即X.X.X.X的形式，用4个十进制数来对应表示4个字节的二进制数值，数值中间用“.”隔开。</li> <li>每个十进制数的取值在 0～255之间。
<ul><li>由于A类地址中首位为0(0XXXXXXX)，所以其第1个十进制数的取值范围被限定于1～126(2的7次方128个)之间(0和 127另有指定)。</li> <li>同理，B类地址中第1、2位为10(10XXXXXX)，第1个十进制数的取值范围被限定于128～191(2的6次方64个)之间。</li> <li>C类地址中第1、2、3位为110(110XXXXX)，第1个十进制数的取值范围被限定于192～223(2的5次方32个)之间。</li></ul></li></ul></li></ul> <img src="/assets/img/IP地址类别.a861f3de.png"> <h4 id="_05-a、b、c类私有地址"><a href="#_05-a、b、c类私有地址" class="header-anchor">#</a> 05.A、B、C类私有地址</h4> <ul><li>date: 2020-06-22</li></ul> <p>私有地址(privateaddress)也叫专用地址（私网IP），它们<font style="background:yellow;">不会在全球使用，只具有本地意义。</font></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>A类私有地址：<span class="token number">10.0</span><span class="token punctuation">.</span><span class="token number">0.0</span><span class="token operator">/</span><span class="token number">8</span>，范围是：<span class="token number">10.0</span><span class="token punctuation">.</span><span class="token number">0.0</span><span class="token operator">~</span><span class="token number">10.255</span><span class="token punctuation">.</span><span class="token number">255.255</span>
B类私有地址：<span class="token number">172.16</span><span class="token punctuation">.</span><span class="token number">0.0</span><span class="token operator">/</span><span class="token number">12</span>，范围是：<span class="token number">172.16</span><span class="token punctuation">.</span><span class="token number">0.0</span><span class="token operator">~</span><span class="token number">172.31</span><span class="token punctuation">.</span><span class="token number">255.255</span>
C类私有地址：<span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">0.0</span><span class="token operator">/</span><span class="token number">16</span>，范围是：<span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">0.0</span><span class="token operator">~</span><span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">255.255</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><img alt src="https://uploadfiles.nowcoder.com/images/20171101/9430388_1509499582678_79540D335CBD37FB9AC1EC8191B91765"> <h3 id="_1-5-单工-半双工-全双工"><a href="#_1-5-单工-半双工-全双工" class="header-anchor">#</a> 1.5.单工-半双工-全双工</h3> <ul><li>3种通信方式：单工通信、半双工通信、全双工通信</li></ul> <h4 id="_5-1-暴力版"><a href="#_5-1-暴力版" class="header-anchor">#</a> 5.1. 暴力版</h4> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>- 单工模式：
  我打你 你不能还手  打你这个过程是发送  你抗揍这个过程是接收『比如，遥控器』
- 半双工模式：
  - 我打你  你不能还手  
  - 过一会儿 你打我 我不能还手
- 全双工模式：
  - 俩人互殴 
  - 我俩可以同时出拳（同时发送）同时抗揍（同时接收）😊😊😊😊😊😊
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_5-2-蜜雪冰城版"><a href="#_5-2-蜜雪冰城版" class="header-anchor">#</a> 5.2.蜜雪冰城版</h4> <ul><li><p>2021.06.27</p></li> <li><p>单工模式：</p> <ul><li>无时不刻，蜜雪冰城接收你的爱</li></ul></li></ul> <p><font style="background:yellow;">无时不刻『你爱我』</font></p> <p><img src="https://cdn.jsdelivr.net/gh/HACV/picture/img/01.%E5%8D%95%E5%B7%A5.png" alt="01.单工"></p> <ul><li>半双工模式：
<ul><li>3点整，你爱我</li> <li>5点整，我爱你
<img src="https://cdn.jsdelivr.net/gh/HACV/picture/img/02.1.%E5%8D%8A%E5%8F%8C%E5%B7%A5.png" alt="02.1.半双工"></li></ul></li></ul> <p><img src="https://cdn.jsdelivr.net/gh/HACV/picture/img/02.2.%E5%8D%8A%E5%8F%8C%E5%B7%A5.png" alt="02.2.半双工"></p> <ul><li>全双工模式：</li></ul> <blockquote><p>无时不刻，『你爱我，我爱你』</p></blockquote> <p><img src="https://cdn.jsdelivr.net/gh/HACV/picture/img/03.%E5%8F%8C%E5%B7%A5.png" alt="03.双工"></p> <blockquote><p>图片来源：蜜雪冰城</p></blockquote> <h3 id="_1-6-心跳包"><a href="#_1-6-心跳包" class="header-anchor">#</a> 1.6.心跳包</h3> <ul><li>server/client    保持连接状态</li></ul> <p>心跳检测机制
<strong>在TCP网络通信中，经常会出现客户端和服务器之间的非正常断开，需要实时检测查询链接状态</strong>。常用的解决方法就是在程序中加入心跳机制。
<strong>Heart-Beat线程</strong>
这个是最常用的简单方法。在接收和发送数据时个人设计一个守护进程(线程)，<strong>定时发送Heart-Beat包</strong>，客户端/服务器收到该小包后，立刻返回相应的包即可检测对方是否实时在线。
该方法的好处是通用，但缺点就是会改变现有的通讯协议！大家一般都是使用业务层心跳来处理，主要是灵活可控。
UNIX网络编程不推荐使用SO_KEEPALIVE来做心跳检测，还是在业务层以心跳包做检测比较好，也方便控制。</p> <h3 id="_1-7-乒乓包"><a href="#_1-7-乒乓包" class="header-anchor">#</a> 1.7.乒乓包</h3> <p>和心跳包类似，但是它可以携带少量的数据
比如，微信的朋友圈红点。</p> <h2 id="✅概念辨析『重要』"><a href="#✅概念辨析『重要』" class="header-anchor">#</a> ✅概念辨析『重要』</h2> <h3 id="_01-链路层、网络接口层、数据链路层"><a href="#_01-链路层、网络接口层、数据链路层" class="header-anchor">#</a> 01.链路层、网络接口层、数据链路层</h3> <ul><li><code>7层</code>模型中，只有『数据链路层』的说法（巫<strong>术</strong>忘传会表应）</li> <li><code>TCP/IP</code>4层模型中，只有『链路层』或者是『网络接口层』的说法，注意概念！</li></ul> <h3 id="_02-区分arp和rarp"><a href="#_02-区分arp和rarp" class="header-anchor">#</a> 02.区分ARP和RARP</h3> <blockquote><p>记忆方法：</p> <p>ARP和RARP，对应短和长</p> <p>IP和MAC，对应短和长</p></blockquote> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>ARP是借助IP地址，请求MAC地址	『短短长』
RARP是借助MAC地址，请求IP地址	『长长短』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li>游双，《<a href="https://book.douban.com/subject/24722611/" target="_blank" rel="noopener noreferrer">Linux高性能服务器编程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》</li> <li>陈硕，《<a href="https://book.douban.com/subject/20471211/" target="_blank" rel="noopener noreferrer">Linux多线程服务端编程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》</li> <li>史蒂文斯 / 芬纳 / 鲁道夫，《<a href="https://book.douban.com/subject/1500149/" target="_blank" rel="noopener noreferrer">UNIX网络编程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》</li></ul> <p>title: 网络协议基础<br>
date: 2020-08-06</p> <h2 id="网络基础"><a href="#网络基础" class="header-anchor">#</a> 网络基础</h2> <ul><li><font style="background:yellow;">约定，以后用的网络层次，仅用『TCP/IP四层』中的术语</font></li> <li>『我们的网络编程研究的是4层模型，不是我们教学中的5层模型，注意！</li></ul> <h2 id="_01-基本概念"><a href="#_01-基本概念" class="header-anchor">#</a> 01. 基本概念</h2> <h3 id="_1-1-协议"><a href="#_1-1-协议" class="header-anchor">#</a> 1.1.协议</h3> <ul><li><strong>协议</strong>：相互约定的“数据<strong>传输</strong>”和“数据<strong>解释</strong>”的规则，协议是在数据传输之间就已经制定好了。</li></ul> <h3 id="_1-2-协议格式"><a href="#_1-2-协议格式" class="header-anchor">#</a> 1.2.协议格式</h3> <ul><li>了解基本的或者说常用的协议格式</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>数据包基本格式:
数-应-传-网-链路   我们扔到网络环境中的这个数据包，这个数据包的基本格式。
也就是协议的总体格式是哪些？

以太网帧（链路层）格式
arp数据包格式——arp攻击  
IP段格式（网络层）——IP 32  
TCP/UDP（传输层）——prot 16——65535    
TCP格式是我们整个网络编程当中比较重要的一种格式！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_02-c-s和b-s"><a href="#_02-c-s和b-s" class="header-anchor">#</a> 02.C/S和B/S</h2> <h3 id="_2-1-c-s架构"><a href="#_2-1-c-s架构" class="header-anchor">#</a> 2.1.C/S架构</h3> <ul><li>优点：</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>  1.协议的选用灵活，我们可以采用我们『自定义』的协议，并不一定要遵循现有的协议。
  典型的，比如电脑上的QQ软件。客户端，典型的C/S架构。
  2.数据可以提前缓存，比如，游戏的第一次的缓存。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>缺点：</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、每次使用，要下载客户端。
客户端装在你主机上，你也不知道对你电脑做了什么事情，比如3Q大战，
『360和QQ』互相喷，客户端对用户的安全构成威胁。
2、需要开发客户端和服务端，两个需要联合调试，调试困难，
『联调』（联合调试）非常闹心。而且，开发量也大。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_2-2-b-s架构"><a href="#_2-2-b-s架构" class="header-anchor">#</a> 2.2.B/S架构</h3> <ul><li>优点：</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.由于不会给主机安装客户端，啥的，相对来说，安全性要高一些。
2.只需要开发服务器端，你采用B/S模式，你所要选用的协议就是http协议，你既然选用这个模式，
你就要对这个协议进行『完整』的支持，『你用或者不用的这个部分，你都要支持他。』
3.跨平台，比如网页游戏，无论是在Linux还是Windows
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>缺点：</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、必须支持http协议，而且不能对http裁剪，你必须支持所有，即使这个模块你不用。但是你得支持。
2、数据是现加载，现缓存。所以，一般网页游戏是2D游戏，而不是3D游戏。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_2-3-总结"><a href="#_2-3-总结" class="header-anchor">#</a> 2.3.总结</h3> <p>老实说，C/S和B/S互补<br>
数据量访问比较大：C/S模型<br>
应用程序稳定性高：C/S模型</p> <h2 id="_03-tcp-ip4层模型和os"><a href="#_03-tcp-ip4层模型和os" class="header-anchor">#</a> 03.TCP/IP4层模型和OS</h2> <ul><li>网络分层模型</li> <li><font style="background:yellow;">在我们的Linux操作系统中，我们的一般的<strong>应用程序</strong>的角度出发，我们重点掌握的是<strong>TCP/IP四层模型</strong>结结构（注意这句话）</font></li> <li>7层和4层，其实说的是一回事，只不过，划分的理论依据和方式不太一样而已。</li></ul> <h3 id="_3-1-7层模型和tcp-ip4层对应方式"><a href="#_3-1-7层模型和tcp-ip4层对应方式" class="header-anchor">#</a> 3.1.7层模型和TCP/IP4层对应方式</h3> <p>7层模型记忆法：  物数网传,会表应（<strong>巫术忘传会表应</strong>）<br>
有一说一，这个首先的学习方法就是硬背。（比如，你小时候背99乘法表，最开始不晓得干啥的，后面就开窍了，这个也是这样，暂时无法给你讲很多辅助知识，所以只能硬记）</p> <center><font size="5" style="background:yellow;">七层协议</font></center> <table><thead><tr><th>7层</th> <th>说明</th></tr></thead> <tbody><tr><td>物理层</td> <td>在网络通信过程当中，你所使用到的一<strong>些物理设备</strong>的一些<strong>标准</strong>。比如双绞线，光纤，我们现在使用的是光纤，早期的话，还会提到同轴电缆这样的东西。这里面所涉及到你网线的接口，它什么样的类型，都在这个里面都有一个限定。指定。还有就是你使用的这个物理设备是按照什么方式去传播的？也就是我们通常所说的bit位。传输速率是每秒多少bit，其实还有我们提到的数模转换与模数转换，高低电平的转化。</td></tr> <tr><td>数据链路层</td> <td>主要，实际上是针对我们网络当中，<strong>物理层接受过来的数据</strong>，进行<strong>校验</strong>的，它主要是数据进行侦测和校验。<br>比如说，你数据传输过来，有没有数据的丢失啊。是否有错误啊。在它的底层有个简单的二进制的校验的规则。</td></tr> <tr><td>网络层</td> <td>指定我们在传输的过程当中，提供的<strong>网络访问的路径</strong>？？<br>比如说，我们知道，<strong>你要想数据包在网络当中传输，必须要给他指定一个唯一的IP地址</strong>。<br>指定完IP地址之后，它通过IP地址在你当前比较<strong>繁杂的网络环境当中，进行寻路</strong>。<br>通过路由的跳转，最终到达目的地。它为什么能够到达目的地？主要是你给它传的IP地址而到达的。</td></tr> <tr><td>传输层</td> <td>对应的信息更加进一步了，主要携带的是<strong>端口号</strong>。<br>可能大家不晓得这个端口号代表的是啥？<br><font style="background:yellow;"><strong>实际上，端口号实际上代表我们之前讲过的（进程）</strong><br>但是，我们每一个进程扔到网络环境当中的时候，会给你这个进程配上一个唯一的端口号，<br>那因此，一个唯一的端口号，可以代表一个进程，咋们知道，进程在你当前的计算机中是唯一的。</font>正是因为这个进程在计算机当中唯一，加上网络层中IP地址在网络环境当中也是唯一的。所以，它就可以在网络当中游走了。**所以，我们传输层和网络层，我们通常说他们两是捆绑使用的。**因此我们经常说“网络 传输”通常说的“网络传输&quot;就是指的这2层而言。</td></tr> <tr><td>会话层</td> <td>所谓的会话层和表示层：<br>实际上是对我们传输层，上层的数据进行间接的封装和解封装的这样的一个过程。<br>也是为了对数据进行确认的。<br>在好多上面，会对回话和表示进行一个打包处理。<br><strong>因为我们刚刚强调，你的这个会话层和表示层和应用层，在TCP/IP模型里面，统一把他称为，应用层。</strong><br>因为这里面，这3层的分工不是那么的明确。<br>主要是对我们发送过来的信息，进行再一次的封装。</td></tr> <tr><td>表示层</td> <td></td></tr> <tr><td>应用层</td> <td>重点强调这个应用层：<br>这个应用层，主要是<strong>针对我们应用程序</strong>而言，所封装的一些协议。比如FTP，http<br><strong>主要是为了方便用户对数据进行访问，把数据包拿过来，进行访问（深刻理解这句话）</strong><br><font style="background:yellow;">而我们的，电子邮件、文件传输和终端仿真,这些是我们在“应用层”<strong>上面</strong>封装的一些协议。它是直接在我们的应用程序里面要用到的</font><br>所以说，你编写的应用程序直接会用到的协议是哪层的协议？？应用层协议。</td></tr></tbody></table> <br> <center><font size="5" style="background:yellow;">TCP/IP四层（重点）</font></center> <ul><li>1、网络接口层（也有书叫：链路层）</li> <li>反正就是最接近底层的—&gt;网络层（主要用到协议：IP协议）—&gt;传输协议（一般用到TCP/UDP协议）—&gt;应用层（比如，FTP协议，SSH协议，FTPS，<strong>USB协议，蓝牙的协议？？</strong>）</li> <li>2、以太网帧协议，加上帧头和帧尾之后，会对应有一个以太网的驱动程序，也就是说，通过以太网驱动，由我们的网卡，把我们的数据包扔到，以太网环境当中。然后，下面的那根线，实际上模拟的就是我们网络环境。</li></ul> <table><thead><tr><th>TCP/IP</th> <th></th> <th>对应的ISO7层模型的</th></tr></thead> <tbody><tr><td>链路层（网络接口层）</td> <td><font size="2">最后，链路层的协议叫做——<strong>以太网帧协议</strong>。</font></td> <td>物理层、数据链路层</td></tr> <tr><td>网络层</td> <td></td> <td></td></tr> <tr><td>传输层</td> <td></td> <td></td></tr> <tr><td>应用层</td> <td></td> <td>表示层、会话层、应用层</td></tr></tbody></table> <p>而下边这些协议，实际我们，会在应用程序中用到吗？不会！！！！
<strong>也就是，除了第7层之外的其他协议，你是不会在你编写的程序当中用得到的；</strong></p> <p>我们所写的应用程序，默认都是封装好了以后直接向下发送，
比如，你在程序当中遵循的http协议，那你要遵循它的get，set方法，遵循它的这个方法，按照这个方法，去写你的数据流。写好了以后，就表示我们支持了http协议，当你程序运行起来之后，操作系统会帮助你调用以下的这些底层，1-6层。这些活都是谁干的？？？都是操作系统干的。</p> <ul><li>问题：我的应用程序当中，我有可能使用到“网络层”或者“传输层协议”啊，这
那这个时候，你在使用的还是<strong>TCP/IP模型</strong>吗？就不是了，如果你在应用程序当中，使用到了这些协议的话
说明你<strong>使用的不再是默认的TCP/IP模型</strong>。
而我们选用的是什么协议啊？？
<strong>自定义</strong>的协议！！！！
如果说，你采用的是<strong>自定义的协议</strong>的话，我们才会在“网络层”或者“传输层“涉及到协议的这种概念。</li></ul> <p>有了4层模型的基本认识之后（注意，是TCP/IP 4层模型）我们接下来要讨论的是<strong>我们的数据包如何封装，借助这4层协议，完成网络传输。</strong></p> <p>首先，准备数据“啥时候还我钱”  （这个时候，要是直接放网络中，会被网络的海浪淹死）
然后，在这个数据之外，封装上了应用层数据（这个时候，要是直接放网络中，还是会会被网络的海浪淹死）
然后，在上面的基础上，继续封装传输层协议的，（这个时候，要是直接放网络中，照常会被网络的海浪淹死）
然后，在上面的基础上，继续封装网络层协议的
然后，在上面的基础上，继续封装链路层（前后，头和尾都封装，这个和以前的不一样）层协议的
（这个时候，再放网络中，不会被网络的海浪淹死，可以正常传输）</p> <p>注意，上面的，<font style="background:red;">数据包的逐层封装，都是操作系统帮你干的！！,不需要我们自己来封装（也就是说，不是我们写的client.c里面做的）</font>（比如，上面，你写的数据，被封装上应用层，这是OS帮你干的的）同样，解封装，也是操作系统帮你做的。
所以，你的数据，在网络传输前，需要操作系统帮你，你的数据才能传输。</p> <p><strong>最后要了解，你的数据最终是从哪里出去的？？
一定是从你的网卡里面传输出去的。所以，你的网卡要传输到你的网络环境里面。当然，这期间，可能需要经过路由器，交换机</strong>
数据要想传输，必须进行封装！</p> <h3 id="_3-2-计算机网络中的os『重要』"><a href="#_3-2-计算机网络中的os『重要』" class="header-anchor">#</a> 3.2.计算机网络中的OS『重要』</h3> <table><thead><tr><th>2大区域</th> <th>对应TCP/IP模型</th></tr></thead> <tbody><tr><td>内核区域（kernel区）</td> <td>链路层，网络层，传输层</td></tr> <tr><td>用户区域（user区）</td> <td>应用层</td></tr></tbody></table> <ul><li>1、对于用户来说，我只处理，<strong>应用程序</strong>的细节。</li> <li>2、对于内核来说，它处理<strong>通信</strong>的一些细节。
比如，客户端首先封装好FTP协议，然后向下交给传输层。</li> <li>3、所以，我们强调，这个数据的<strong>封装</strong>实际上是由我们操作系统来帮我们完成的。</li> <li>4、问题：那你这个用户区，万一用到协议呢？那需要我们在编程的过程当中对这个协议进行支持。比如，你使用FTP。你就需要使用它的put和GET</li></ul> <h2 id="_04-自底向上4层模型"><a href="#_04-自底向上4层模型" class="header-anchor">#</a> 04.自底向上4层模型</h2> <ul><li>逆向思维</li></ul> <p><strong>上半部分重点：数据包的封装！</strong></p> <h3 id="_4-1-以太网帧『网络接口层』"><a href="#_4-1-以太网帧『网络接口层』" class="header-anchor">#</a> 4.1.以太网帧『网络接口层』</h3> <p>在说以太网帧格式之前，你首先要明白，我现在要讲的这个格式，它在我们数据包里面扮演什么角色？？
<strong>以太网帧，是在我们最外层的——网络接口层（链路层）（TCP/IP模型当中）</strong></p> <p>现在我们来看看，链路层如何帮助我们完成数据包的找寻。
如图，6字节目标地址，6字节的源地址，2字节的类型，<font style="background:yellow;">4字节的校验（CRC）<strong>（注意，这个4字节的，就是我们每次画画的时候那个，帧尾那个玩意！！！）</strong></font>
我们刚开始，知道链路层，主要用来校验。</p> <p><font style="background:yellow;">注意，上面的目的地址和源地址，不是IP地址，而是对应的电脑里面的硬件地址（MAC地址，所谓的MAC地址，实际上就是网卡的编号，对应你每个人都有的身份证，这个编号保证这块网卡在网络应用环境当中，是唯一的。）比如，我们Linux下ifconfig就能看到</font></p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>也就是说这个网卡编号，在全世界，不会出现重复（神奇）

这个网卡编号，实际上，在网卡出厂之前，比如说英伟达公司，在生产网卡之前，就已经把编号指定好了。

全世界，会专门有这样的组织给分配，比如说，全世界生产这个的厂商，假如说3
家，他们在生产网卡之前，会收到一个网卡编号的使用范围！比如，1号厂商，
1000-5000，2号为5001-10000这样的意思。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>注意：以太网帧的，这个目的地址指的是，我的这个数据包<strong>将要去到的下一个网卡</strong>的MAC地址是多少。而我的这个源地址是指的，我自己的MAC地址。</li> <li>那么问题来了：我的这个数据包发送出来，要经过路由器，要经过好多，我怎么知道我的这个数据包要发送的下一块网卡的MAC地址是多少？？怎么知道它的下一个MAC地址是多少？因为，我们知道，我们自己的机器，有我们自己的MAC，路由器有属于路由器自己的MAC。</li> <li>因为路由器，也是网络终端设备。它也有属于自己的网卡，每个路由器都有一个MAC，当我从这到这个，我是怎么知道他的MAC地址的呢？？？需要借助的是，我们接下来要讲的ARP请求，在以太网帧中，我们知道2个字节表示，以太网帧的类型！</li> <li>当你的这个类型传递：
0800的时候，表示我是普通的以太网数据包，后面跟的是数据
0806，表示我的以太网帧发送的是一个ARP请求包，而发送不是数据。ARP请求包，用来请求，下一跳的MAC地址。</li></ul> <p>**以太帧中，有一个特殊的协议，也就是ARP协议，**这个ARP协议，就是专门用来获取。下一个，我要经过的路由器的MAC地址的。</p> <p>也就是说，我们这个协议，它是一个一般化的格式，或者说是个模板，我通过模板里面。这个2字节的变化，来达到发送不同数据的目的。下面，我们来看看那个28个字节的ARP数据报</p> <h3 id="_4-2-arp数据报『网络层』"><a href="#_4-2-arp数据报『网络层』" class="header-anchor">#</a> 4.2.ARP数据报『网络层』</h3> <p>6+6+2+++28+18的PAD（原因是，我要28+18才能达到最小的46个字节，满足人家那格式才行，言外之意，这18个字节没啥用，真正有用的是那28个字节）</p> <ul><li><strong>PAD表示——填充</strong></li></ul> <blockquote><p>PS（小知识）：所以iPad怎么来的？就是为了完成一个填充，填充iPhone和Mac因为苹果出iPhone的时候，那个iPhone大概是4英寸大小，而我们的Mac最小的一般是11或13寸大小，因此，它在这两个大小之间，填充了一个9寸的大小，所以取名iPad，其实是为了填充屏幕中间的这一段空白。</p></blockquote> <p>我们主要关注28字节中，这些部分
6字节的发送端的以太网地址，
4字节发送端的IP地址，
6字节大小目的以太网地址
4字节目的IP地址</p> <p>比如，我在发送<strong>ARP请求</strong>的时候，我们不知道目的地址是多少</p> <p><strong>(1）所以，我们将前6个字节填充为0（目的MAC地址）</strong></p> <p>（2）6个字节（自己的源MAC地址）</p> <p>(3)2字节，帧类型，0806</p> <p>6字节的发送端的以太网地址，（同（2）中一样）
4字节发送端的IP地址（填充好）
6字节大小接收端以太网地址(<strong>填上全0，因为现在还不知道)</strong>
4字节接收端IP地址（填充，知道的IP，因为，你IP都不知道，那就没有办法传递了。。）</p> <p>ARP请求包，会把我们封装好的这个数据包，扔到网络环境当中，然后，<strong>把网络环境当中，所有的，我能连接的，都发送一下。（这叫广播把）</strong>
当他们收到之后，发现发过来的目的MAC地址竟然是全0，它会讲目的IP和自己的IP进行比较，
如果发现是自己的IP，那他就做什么操作？？？我帮你做填充，将我的MAC地址填充好。
然后，填充好之后，发送回一个，回复：但是回复是这样的。
同样，它的这个包，也是向我网络环境当中，我能连接的所有的路由，或者是终端进行发送。
发送到之后，每个人都会检查自己的IP，要是对不上则扔掉。
要是先前那个发送的，收到了，发现有目的IP，也就表示，我先前发送ARP请求包，它给了我回应了。
这样就知道那个目的MAC了。</p> <p><font style="background:yellow;">就是通过上面这种方式，在我们的网络环境中，从这个节点，选择到这个节点。。。（但是，我还是不懂，什么鬼）</font></p> <p>注意，ARP数据报，是干嘛的？
获取MAC地址的，确切的来说，是获取<strong>我下一个即将要把数据包投递的。那个路由的MAC地址</strong>。
我们把这个<strong>路由</strong>称之为我的“下一跳”；</p> <p>那么我的数据报，在我一个路由一个路由之间传输，这每一个路由节点，我们又称之为“一跳”
形容，数据包，从这蹦到这。。</p> <p>ARP数据报，所谓数据报，就是去完之后，就没有回了。有去无回的数据报？？？
什么鬼
arp数据报;获取下一跳的mac地址。</p> <p>我们的数据包每到一个路由器，都要完成一个数据包的解包和打包（但是，不是完全的解包罗）</p> <p><font style="background:yellow;">问题：（难点，重点）
ARP数据包中的，发送端IP地址是本机IP，那么目的IP地址呢？？
是我数据包，最终去往的那个IP地址吗？？还是我的目前的下一跳的IP地址？？
答案：<strong>下一跳的IP地址</strong>
那么问题来了，最终去往的那个IP放在哪里呢？？？
封装在了我们的网络层，具体说是封装在网络层的IP协议当中（这是，计算机网络的核心知识点之一，个人认为，事实上也是的）
</font>
所以，也解释了，每到一个路由器，要解包:解数据链路层的，解网络层的。</p> <p><font size="5" style="background:yellow;">（重点：理解这里，计算机网络水平就上升很多了）这样，我就明白了数据包，如何寻路，其实就是利用数据链路层（ARP广播）和网络层（IP）</font>从网络层中，根据你要传输的，<strong>最终目的IP</strong>，通过路由器中的路由表，进行寻路。
路由器参照自己内部的路由表，帮助我进行寻路，就是决定路由器应该下一跳。知道下一跳，我就知道下一跳的IP地址了。然后，可以把这个往ARP的目的IP添。，然后重复先前的ARP广播，一步步的这么跳下去。
这样，我清晰了。</p> <p>但是，在这个基础上，我又有一个疑问：那我们新开的一个路由器，投入网络使用的时候，最初是怎么知道，相邻的路由器的呢？？？？难道是手工？？？</p> <p>加餐：网络环境很差，各种最优的选择的路由器直接断开，怎么办？？
所以就只能，发一些其他路由器，看能不能从你那里绕过去。
而且，很低概率上，甚至会在好几个路由器之间死循环——————这种数据包，要是很多的话，就会拥塞住你当前的网络环境。
为了为了防止这种死循环，我们所有的数据包在发送的时候，要经过多少跳才能送到最终的终点的地方，这个上限有限定的！！！比如，我跳了100跳了，还没有到达，，，我们就会考虑丢弃这个。
**我们把这个上限，称之为TTL（就是你的这个数据包，在网络传输过程当中的最长生命周期，一般是以1跳为单位）**比如TTL=56，表示最多经过56个路由器，要是经过这么多，还没有到，，，
**因为每经过一个路由器，就把TTL减1；**那最后一个路由器把他丢弃。也就是把TTL减为0的路由器。
这样就保证了，就算在网络环境很差的环境下，也不会拥塞我们的网络。</p> <h3 id="_4-3-路由器寻址『网络层』"><a href="#_4-3-路由器寻址『网络层』" class="header-anchor">#</a> 4.3.路由器寻址『网络层』</h3> <p>问，我封装好的数据包，怎么会，从这端到那一端？
原因是数据包里面有一层是IP地址。
显然，它在实际进入网络环境的时候，它会根据我们的 IP地址去进行寻路。
实际上，当我们的数据包从网卡里面出来的时候，实际上，它可以选择的路好多条。
这些，都有可能到达目的地，所以=，我们形象称为“网”
路由器——
路，
由：经由的意思，我从这条路走到这边会经由哪些站点？也就是说，我选路的一个过程。
你实际选择了哪些路由器，作为我的经过，我们把这个路由器，称为我的一个路由节点。</p> <p>在每个路由节点里面，会有一个路由表！路由表是什么？
表格，表格内部记录了一条条路由信息。
路由表记录了，我的路由器连接了哪些路由器，也就是说，我会把你的数据包，接下来发送给哪些路由器。</p> <p>注意，元地址，我自己的路由是192.168.1.23
我目标的路由是192.168.10.56
显然，它要把他的<strong>目标路由</strong>记录在里面。
然后发现，下面的192.168.45.67更接近我的路由？？
所以，选他。</p> <p>我们把，路由器参照自己的这个路由表在选择，数据包下一个发送位置的过程，我们把他称之为寻路。
（我要寻找我的下一个路由节点）</p> <p><font style="background:yellow;">注意：对于TCP协议来说，它的寻路，一般情况下只有一次。
就是当数据包第一次发送的时候。</font>
一旦，我把这条路建立好了之后，假如说，我要发送一个小说过去。这个小说显然，要发送好多这样的数据包发送。
<font style="background:yellow;">一旦，我把这条路建立好了之后，那么后续，它所有的数据包都是按照这条路径来走的@！！</font>
因此，我们说，TCP在数据传输过程当中，稳定，因为我传输数据的路由是固定的！！！</p> <p>如果是UDP协议就不一样了，由于，它没有<strong>建立通路</strong>的这样一种机制！！
所以，它可能第1个走这条路，第2个走这条。
也就是说，UDP协议在选择的时候，它每次都要干啥？它<strong>每次</strong>都要进行一次寻路操作！！！</p> <p>注意：你的数据包在封装的时候，里面要封装一个IP，这个IP地址里面记录的是，我要发送的数据包的<strong>目标位置</strong>！而这个IP地址，也是我路由器寻路的一个依据，那么实际上，路由器在寻路的时候，它单纯的是依据我们的这个IP吗？实际上不是的，路由器要寻路不假，但是在寻路的过程当中，它不单单，依照我们这个IP还依照我们这个谁呢？？？也就是我们数据包里面的，以太网帧！！！</p> <h3 id="_4-3-ip段格式『网络层』"><a href="#_4-3-ip段格式『网络层』" class="header-anchor">#</a> 4.3.IP段格式『网络层』</h3> <p><strong>4位版本号</strong>：IPv4和Ipv6（其实IPv6主要是国内在推动，毕竟最初IP地址在定位的时候，就是欧美组织在定的，当时下发的时候，几乎就是按照基础的科研单位，就是最小的科研单位，比如到学校的院系，去划分）
当我们国家的计算机起步，人家几乎分完了，没办法找别人硬要，要来了一部分IP，给我们开发。
所以说，给我们的IP少得可怜，我们整个国家的IP，范围和别人一所学校的范围，几乎差不多。。。</p> <p>但是已经推了很多年了。</p> <p><strong>4位首部长度</strong>：IP地址的首部的长度是20字节，其实就是记录在这。
16位总长度（字节数）：描述的是IP段总体的长度
16位标识<br>
3位标志<br>
13位片偏移
8位生存时间（TTL）：表示数据包在网络当中能够经过多少个路由器。（记住，TTL在IP段里面记录）
问题，要是中国到澳大利亚，256跳够吗？？？额。你的跳数和你的物理距离无关。有可能到澳大利亚，海底光缆，3跳就过去了，有可能到广州需要经过几十跳。这都有可能。
8位协议
16位首部校验和：在IP段这一层，进行你这个数据包的校验。
32位源IP地址：最初的IP地址(强调)
32位的目的IP：最终的IP地址（强调，
注意，是32位，4字节的IP地址，编程的时候，记得哈
你程序当中的IP一定受到这个限制！！！</p> <p>联系：<font size="5" style="background:yellow;">IP层封装的这些东西，对于，以太网帧格式来说，是它的什么部分？？是它的数据，，，比如在前面的前面的图中，对应的是46-1500字节的那个里面</font></p> <h3 id="_4-4-tcp-udp『传输层』"><a href="#_4-4-tcp-udp『传输层』" class="header-anchor">#</a> 4.4.TCP/UDP『传输层』</h3> <ul><li><strong>由于TCP和UDP都位于传输层，言外之意，在传输层的时候，我们要做一个协议选择。</strong></li></ul> <h4 id="udp数据报格式："><a href="#udp数据报格式：" class="header-anchor">#</a> UDP数据报格式：</h4> <p>端口号用来描述，进程。（毕竟IP只能找到电脑，端口号才能找到那个电脑上哪个进程）</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>16位源端口号：（这2个东西，在编程之前，我们私下已经定好了）
16位目的端口号：（这2个东西，在编程之前，我们私下已经定好了）比如，说，你
个人的IP，你需要通过打电话，或者发电报的方式提前知道。
端口号在我们封装，C/S模型或者B/S模型的时候，我们指定好端口号是多少，比如
说，B/S模型，端口号是8080端口，这都固定的端口，
16位UDP长度：
16位UDP校验和
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="tcp数据报格式："><a href="#tcp数据报格式：" class="header-anchor">#</a> TCP数据报格式：</h4> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>显然和UDP都是属于传输层协议，那么都有
16位源端口号：
16位目的端口号：
但是TCP除此之外，还需要有一些东西。
32位序号，（（大概懂
32位确认序号。（（大概懂

4位首部长度：
保留6位:将来，万一协议需要扩展，，，虽然到现在也没用上。
标志位：URG，ACK，PSH，PST，SYN，FIN
16位窗口大小
16位校验和
16位紧急指针
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><font style="background:yellow;">至此，以太网帧层-》网络层-》传输层我们从思路上走了一遍</font></p> <p>这些个协议格式，大概我们都给他们介绍了。</p> <h3 id="_4-5-应用层没有固定格式『重要』"><a href="#_4-5-应用层没有固定格式『重要』" class="header-anchor">#</a> 4.5.应用层没有固定格式『重要』</h3> <ul><li>Q：至于，<strong>应用层，它的协议有没有固定格式</strong>？</li> <li>A：没有，比如我们知道，画一条先，下3层是内核部分，应用层是user部分,用户层，你所谓的协议是什么样子的，有多少个头，携带多少个数据应该是<strong>由用户自己来确定的</strong>。所以，它的协议不固定</li></ul> <h2 id="_05-套接字（socket）"><a href="#_05-套接字（socket）" class="header-anchor">#</a> 05.套接字（Socket）</h2> <p>注意：</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>IP地址: 在网络环境中唯1标示1台主机
端口号（Port）:在主机中唯一标示一个进程
IP+port: 在网络环境中唯1标示1个进程
我们把“在网络环境中唯1标示1个进程”称为socket
从这个角度出发，**Socket他必须包含：IP地址和端口号**
因此你在使用socket之前，你需要确认这两个。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>套接字是我们Linux系统当中的一种文件类型，socket是一个文件是一个伪文件。</p> <p>注意：</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>当你创建好一个socket以后，我也是有一个文件描述法（fd）
但是，这一个文件描述法，对应2个缓冲区！
这『2个缓冲』用1个文件描述符来指向。
1个缓冲区，专门用来完成数据的读入，一个用来完成写出。

所以，我们拿着socket去进行数据操作的时候，我既可以向fd当中写数据，也可以从fd里面读数据。
比如：管道，数据是单向流动的，半双工通信
只能一个方向流动，要想2个方向流动，需要2根管道！！！
但是socket不一样，他是双向『全双工』的！！就是，在同一时刻，我既可以数据读入，也可以数据读出嘛。。
（2个缓冲区）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>当你写数据的时候，通过文件描述法，写入到套接字这个伪文件里面。实际上是通过，发送端缓冲区，连接到另外一个套接字的接收端。把数据写过去了。</p> <ul><li>缓冲区是在内核里面给我们提供的一片存储空间，4K大小左右</li></ul> <h3 id="_1、nat『映射』"><a href="#_1、nat『映射』" class="header-anchor">#</a> 1、NAT『映射』</h3> <p>NAT映射机制</p> <p>（数据包在网络当中<strong>传递</strong>里面，经常用到的一些技术名词，主要里面涉及到两个，就是上面两个）</p> <ul><li>提出囧况：<br>
私网IP在公网不可见<br>
比如我们『192.168.X.X』是局域网的IP，只能在局域网中用，进入到公网的IP不会是这样的IP。换言之，这样的IP在公网中是不可见的。</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>在广州发信息给上海，甚至可能，
广州，这边局域网IP是192.168.3.5
上海目的地的局域网IP也是192.168.3.5
这个时候，我们的数据怎么传递呢？
看上去，源IP和目的IP是一样的。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>实际上，对于我们大家来说，我们的网络环境当中，首先数据从网卡 出来<br>
数据包不是直接发送到你路由器上（先前那样画，只是为了标出重点）<br>
而是发送到交换机上！！！交换机给你进行IP地址的转发，发给谁？发给路由器，但是我们说，绝大多数的路由器自带交换机的功能啊！！因此我们说，路由器可以替代交换机的基本作用。</li> <li>为什么，两者能够发送数据呢？？</li> <li>其实在我们的<strong>路由器</strong>当中，除了我们提到的『路由表』之外，其实还有一个『NAT映射表』这个NAT映射表和我们的路由表组织形式差不多，都是表结构。</li> <li>概念：<font style="background:yellow;">NAT映射表记录的是你当前，连接到我们这个<strong>路由器</strong>的终端的<strong>局域IP地址</strong>和公网IP地址的对应关系。
也就是说，路由器它本身所具有的IP，应该是一个公网IP（在整个网络环境当中应该是唯一的）</font></li></ul> <blockquote><p>所以，广州和上海，局域网IP还一样的，如何通信？？</p></blockquote> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>做法：
我的QQ,本地192.168.1.35 ：8000端口号
那么到达第一个路由器（接入的）
在『NAT映射表』中记录，把192.168.1.35：8000映射为当前路由器的IP地址和端口号
比如
192.168.1.35：8000映射为123.24.56.78：1000
这样，这个数据包在向外面进行转发的时候，所有的路由器在接收到数据包的时候。
就不认为数据包是192.168.1.35发出来的了『透明的，将私网给隐藏了』
而是认为，源数据的源IP是123.24.56.78。然后，后续操作就和以前的差不多了。『递归』
因此这样就实现了：虽然我的公网IP只有一个，但是我的这个公网IP可以下发出多个私有IP（局域网）
实际上我们现在用的网络环境，不仅是这样的下发，我们还会再下发。『多层NAT映射，因为人口的增长，这样越来越多层，网络传输就会效率低，所以才大力推进IPv6』
比如，我们自己家的路由器，实际上，你们家里面几个人『对外来说』IP只有一个，但是我们每个人的IP地址不一样。因为我们的IP地址都是私有IP地址。（注意，分清私有IP和公网IP）

NAT映射表解决了，我们中国公网IP地址这么少，但是，到现在能不能访问啊？能够上网。显然，私网和公网IP通信，需要NAT映射表，公网与公网IP不需要用NAT映射表。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_2、nat『穿透』"><a href="#_2、nat『穿透』" class="header-anchor">#</a> 2、NAT『穿透』</h3> <ul><li>NAT穿透，俗称“<strong>打洞机制</strong>”，也称&quot;内网穿透&quot;</li></ul> <blockquote><p>打洞机制的由来：</p> <p>比如QQ聊天，需要经过腾讯服务器，不能直接走。但是显然这个有缺点，聊天文字还好。
那么，视频电话呢？怎么办，要是从腾讯服务器转一手过去，效率会很低的，因为实时性要求高。</p> <p>打洞：主要是为了提高，数据传输的效率。</p></blockquote> <p>实际上也和你的这个路由器有一定的关系，
因为你的数据包从你的这个计算机里面出来了，所有的行为，实际上都是由路由器控制了。</p> <ul><li>『路由器默认的保护机制』：陌生的IP，第一次给我发送数据包，我会把这个数据包屏蔽掉，或者说，丢弃掉，主要是为了防止网络环境的恶意攻击。</li></ul> <p><strong>解决方法</strong>：</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>要想要视频通话的A和B正常通信。
必须，A和B对于这些路由器是熟悉的才行。
这个时候，我们需要在这些普通的路由器直接打个洞。（像老鼠掏洞一样）
因为，原来走法是，要绕道腾讯服务器，现在的走法是直接在其他的路由器直接，掏个洞，钻过去。

但是为了防止路由器，屏蔽陌生IP的话，这个时候，腾讯就参与进来了。因为，我们知道我们的QQ在登录的时候，会访问腾讯的服务器，这样，腾讯和A之间，还有腾讯和B直接的路由器就对这些IP不陌生了。
现在腾讯服务器做了一件事：打洞。
腾讯公网的服务器，来帮助我们。两台私有IP之间完成打洞。
当他把洞打好之后（所以，到达咋样打洞的，俺还是不晓得，），达到的效果就是，A和B直接可以实时通信了。所以，打洞是通过腾讯的公网的服务器来做的！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>所以说，我们要想打洞的话，势必要借助一个公网IP。</strong>
腾讯发现A和B要发起视频聊天，所以腾讯就不给他们转发数据了，那样太慢了，</p> <ul><li><p>打洞机制是谁来完成的？是服务器（公网方服务器）</p></li> <li><p>当然，私网中的局域网的话，就不需要NAT映射和打洞机制。和公网和公网，类似，可以直接访问！</p></li> <li><p>这也解释了，为什么，两个在局域网设置IP，不能一样，因为一样的话，就会显示冲突了。</p></li></ul> <h2 id="参考资料-2"><a href="#参考资料-2" class="header-anchor">#</a> 参考资料</h2> <ul><li>[美] James F.Kurose / [美] Keith W.Ross，《<a href="https://book.douban.com/subject/26176870/" target="_blank" rel="noopener noreferrer">计算机网络-自顶向下方法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》</li> <li>[日]竹下隆史 / [日]村山公保 / [日]荒井透 / [日]苅田幸雄，《<a href="https://book.douban.com/subject/24737674/" target="_blank" rel="noopener noreferrer">图解TCP/IP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》</li> <li>[日]上野宣，《<a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener noreferrer">图解HTTP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》</li> <li>花生壳，<a href="https://hsk.oray.com/news/6783.html" target="_blank" rel="noopener noreferrer">内网穿透原理是什么？nat内网穿透如何实现？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.dfedf38e.js" defer></script><script src="/assets/js/8.662933a2.js" defer></script>
  </body>
</html>
