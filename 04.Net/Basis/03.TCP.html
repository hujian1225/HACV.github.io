<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TCP详解 | HACV</title>
    <meta name="description" content="Personal Blog Website">
    <link rel="icon" href="/images/photo.jpg">
  <link rel="manifest" href="/images/photo.jpg">
  <link rel="apple-touch-icon" href="/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.8eb0d87d.css" as="style"><link rel="preload" href="/assets/js/app.1fba1c74.js" as="script"><link rel="preload" href="/assets/js/43.7a79755c.js" as="script"><link rel="prefetch" href="/assets/js/10.9f12aa84.js"><link rel="prefetch" href="/assets/js/11.efe5693b.js"><link rel="prefetch" href="/assets/js/12.ba81f444.js"><link rel="prefetch" href="/assets/js/13.ab81d384.js"><link rel="prefetch" href="/assets/js/14.60dbb38c.js"><link rel="prefetch" href="/assets/js/15.ed38fa09.js"><link rel="prefetch" href="/assets/js/16.3c5d4ef4.js"><link rel="prefetch" href="/assets/js/17.9972b8eb.js"><link rel="prefetch" href="/assets/js/18.c9db9a32.js"><link rel="prefetch" href="/assets/js/19.f6e77355.js"><link rel="prefetch" href="/assets/js/2.43bd8d8d.js"><link rel="prefetch" href="/assets/js/20.212e0126.js"><link rel="prefetch" href="/assets/js/21.c14639d8.js"><link rel="prefetch" href="/assets/js/22.6e5b2f67.js"><link rel="prefetch" href="/assets/js/23.10a4855b.js"><link rel="prefetch" href="/assets/js/24.f0f7c5a8.js"><link rel="prefetch" href="/assets/js/25.a1706472.js"><link rel="prefetch" href="/assets/js/26.8cb3457c.js"><link rel="prefetch" href="/assets/js/27.be37cbcd.js"><link rel="prefetch" href="/assets/js/28.68c4ebbd.js"><link rel="prefetch" href="/assets/js/29.36fe9412.js"><link rel="prefetch" href="/assets/js/3.15e8b4af.js"><link rel="prefetch" href="/assets/js/30.6408b0e0.js"><link rel="prefetch" href="/assets/js/31.a1777dcc.js"><link rel="prefetch" href="/assets/js/32.cc830263.js"><link rel="prefetch" href="/assets/js/33.eef672e3.js"><link rel="prefetch" href="/assets/js/34.02f45034.js"><link rel="prefetch" href="/assets/js/35.91415ee3.js"><link rel="prefetch" href="/assets/js/36.8de67fea.js"><link rel="prefetch" href="/assets/js/37.8196dfe6.js"><link rel="prefetch" href="/assets/js/38.5c145cab.js"><link rel="prefetch" href="/assets/js/39.9acd762f.js"><link rel="prefetch" href="/assets/js/4.a42b7175.js"><link rel="prefetch" href="/assets/js/40.88d33359.js"><link rel="prefetch" href="/assets/js/41.0dcb9549.js"><link rel="prefetch" href="/assets/js/42.97870c21.js"><link rel="prefetch" href="/assets/js/44.c0e016d6.js"><link rel="prefetch" href="/assets/js/45.6db387b0.js"><link rel="prefetch" href="/assets/js/46.166ff235.js"><link rel="prefetch" href="/assets/js/47.cf279ad5.js"><link rel="prefetch" href="/assets/js/48.b6d66d1f.js"><link rel="prefetch" href="/assets/js/49.b99f5db0.js"><link rel="prefetch" href="/assets/js/5.9b316b6f.js"><link rel="prefetch" href="/assets/js/50.189d7537.js"><link rel="prefetch" href="/assets/js/51.9967e8d3.js"><link rel="prefetch" href="/assets/js/52.f26dfffc.js"><link rel="prefetch" href="/assets/js/53.0ef2c2ad.js"><link rel="prefetch" href="/assets/js/54.189ff7f1.js"><link rel="prefetch" href="/assets/js/55.4d3d74f4.js"><link rel="prefetch" href="/assets/js/56.957769ba.js"><link rel="prefetch" href="/assets/js/57.2170a64b.js"><link rel="prefetch" href="/assets/js/58.49fde817.js"><link rel="prefetch" href="/assets/js/59.978a2e4e.js"><link rel="prefetch" href="/assets/js/6.24525bd8.js"><link rel="prefetch" href="/assets/js/60.79c422eb.js"><link rel="prefetch" href="/assets/js/61.2e885ec1.js"><link rel="prefetch" href="/assets/js/62.2eac06ad.js"><link rel="prefetch" href="/assets/js/63.284bf11c.js"><link rel="prefetch" href="/assets/js/64.7a4e53a4.js"><link rel="prefetch" href="/assets/js/65.5da5447a.js"><link rel="prefetch" href="/assets/js/66.c656a98b.js"><link rel="prefetch" href="/assets/js/67.6f850b9d.js"><link rel="prefetch" href="/assets/js/68.da833a96.js"><link rel="prefetch" href="/assets/js/69.3552a6ad.js"><link rel="prefetch" href="/assets/js/7.8075d0ae.js"><link rel="prefetch" href="/assets/js/70.c1b7b1ae.js"><link rel="prefetch" href="/assets/js/71.a6f0a617.js"><link rel="prefetch" href="/assets/js/72.84127077.js"><link rel="prefetch" href="/assets/js/73.962f760f.js"><link rel="prefetch" href="/assets/js/74.4b1c87e2.js"><link rel="prefetch" href="/assets/js/75.18e0072b.js"><link rel="prefetch" href="/assets/js/76.a7361629.js"><link rel="prefetch" href="/assets/js/77.d186be57.js"><link rel="prefetch" href="/assets/js/78.a5d3f3e9.js"><link rel="prefetch" href="/assets/js/79.92d6cdda.js"><link rel="prefetch" href="/assets/js/8.21fc4e67.js"><link rel="prefetch" href="/assets/js/80.116c7d45.js"><link rel="prefetch" href="/assets/js/81.a60ad420.js"><link rel="prefetch" href="/assets/js/82.bb296fd8.js"><link rel="prefetch" href="/assets/js/83.37394721.js"><link rel="prefetch" href="/assets/js/84.5af93683.js"><link rel="prefetch" href="/assets/js/85.cec13447.js"><link rel="prefetch" href="/assets/js/86.16268cf5.js"><link rel="prefetch" href="/assets/js/87.4608d6f7.js"><link rel="prefetch" href="/assets/js/88.489dda2e.js"><link rel="prefetch" href="/assets/js/89.4dccc6ea.js"><link rel="prefetch" href="/assets/js/9.f72c9269.js"><link rel="prefetch" href="/assets/js/90.627d9cac.js"><link rel="prefetch" href="/assets/js/91.0699a273.js"><link rel="prefetch" href="/assets/js/92.a3560914.js"><link rel="prefetch" href="/assets/js/93.06392e3f.js"><link rel="prefetch" href="/assets/js/94.ff4f11c6.js"><link rel="prefetch" href="/assets/js/95.f90d8a38.js"><link rel="prefetch" href="/assets/js/96.fe01526f.js"><link rel="prefetch" href="/assets/js/97.a4117e68.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8eb0d87d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">HACV</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/01.About/" class="nav-link">✡️About</a></div><div class="nav-item"><a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></div><div class="nav-item"><a href="/03.OS/" class="nav-link">💻操作系统</a></div><div class="nav-item"><a href="/04.Net/" class="nav-link router-link-active">☁️网络</a></div><div class="nav-item"><a href="/05.SE/" class="nav-link">☕️软件工程</a></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">💾数据库</a></div><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">⭐️硬件和编译</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">🔧Tools</a></div><div class="nav-item"><a href="/09.Language/" class="nav-link">⚛️C/C++</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/01.About/" class="nav-link">✡️About</a></div><div class="nav-item"><a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></div><div class="nav-item"><a href="/03.OS/" class="nav-link">💻操作系统</a></div><div class="nav-item"><a href="/04.Net/" class="nav-link router-link-active">☁️网络</a></div><div class="nav-item"><a href="/05.SE/" class="nav-link">☕️软件工程</a></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">💾数据库</a></div><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">⭐️硬件和编译</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">🔧Tools</a></div><div class="nav-item"><a href="/09.Language/" class="nav-link">⚛️C/C++</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>TCP详解</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/04.Net/Basis/03.TCP.html#一、tcp状态转换『重要』" class="sidebar-link">一、TCP状态转换『重要』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（1）2msl-maximum-segment-lifetime" class="sidebar-link">（1）2MSL (Maximum Segment Lifetime)</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（2）半关闭" class="sidebar-link">（2）半关闭</a></li></ul></li><li><a href="/04.Net/Basis/03.TCP.html#二、端口复用" class="sidebar-link">二、端口复用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（1）2msl的缺点和解决" class="sidebar-link">（1）2MSL的缺点和解决</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（2）用网络的高峰" class="sidebar-link">（2）用网络的高峰</a></li></ul></li><li><a href="/04.Net/Basis/03.TCP.html#三、socket错误处理、三次握手、并发" class="sidebar-link">三、socket错误处理、三次握手、并发</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/04.Net/Basis/03.TCP.html#四、总览" class="sidebar-link">四、总览</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/04.Net/Basis/03.TCP.html#五、网络套接字相关函数『记忆』" class="sidebar-link">五、网络套接字相关函数『记忆』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（1）字节序和主机字节序的转换" class="sidebar-link">（1）字节序和主机字节序的转换</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（2）地址转换函数（比1省略了步骤）" class="sidebar-link">（2）地址转换函数（比1省略了步骤）</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（3）sockaddr数据结构" class="sidebar-link">（3）sockaddr数据结构</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#_1）socket函数（创建套接字）" class="sidebar-link">1）socket函数（创建套接字）</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#_2）bind函数（绑定，" class="sidebar-link">2）bind函数（绑定，</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#_3）listen函数（指定监听上限数，并不是用来监听的）" class="sidebar-link">3）listen函数（指定监听上限数，并不是用来监听的）</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#_4）accept函数（这个函数作用，很重要，" class="sidebar-link">4）accept函数（这个函数作用，很重要，</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#_5）connect函数（建立连接，客户端建立连接）" class="sidebar-link">5）connect函数（建立连接，客户端建立连接）</a></li></ul></li><li><a href="/04.Net/Basis/03.TCP.html#六、tcp的两份代码（要倒背如流）" class="sidebar-link">六、TCP的两份代码（要倒背如流）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（1）服务器代码" class="sidebar-link">（1）服务器代码</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（2）只写了服务器端，如何测试？nc" class="sidebar-link">（2）只写了服务器端，如何测试？nc</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（3）客户端代码" class="sidebar-link">（3）客户端代码</a></li></ul></li><li><a href="/04.Net/Basis/03.TCP.html#七、错误处理函数（让网络编程程序更加健壮）（错误封装，这种思想很重要）" class="sidebar-link">七、错误处理函数（让网络编程程序更加健壮）（错误封装，这种思想很重要）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/04.Net/Basis/03.TCP.html#八、『tcp3次握手和4次挥手』" class="sidebar-link">八、『TCP3次握手和4次挥手』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（1）tcp通信时序" class="sidebar-link">（1）TCP通信时序</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（2）4次挥手（原因）" class="sidebar-link">（2）4次挥手（原因）</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（3）mtu（最大传输单元）" class="sidebar-link">（3）MTU（最大传输单元）</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/03.TCP.html#（4）滑动窗口" class="sidebar-link">（4）滑动窗口</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><p>date: 2020-08-08</p> <h1 id="tcp详解"><a href="#tcp详解" class="header-anchor">#</a> TCP详解</h1> <p><font size="5" style="background:yellow;">Windows和Linux下的netstat命令的配合复习</font></p> <h2 id="一、tcp状态转换『重要』"><a href="#一、tcp状态转换『重要』" class="header-anchor">#</a> 一、TCP状态转换『重要』</h2> <p><font size="5">Windows下可以用命令查看这些状态</font></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">netstat</span> -a
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><font size="5">Linux下，我们测试，服务器的命令（注意，后面的6666是端口号）</font></p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">netstat</span> -apn <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">6666</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>这是我们在网络开发过程当中，进行客户端服务器调试的，一个非常重要的依据和手段。我们可以通过我们看到的各种状态，来达到推测出，客户端或服务器当前处于服务器通信的哪个阶段。</li></ul> <p>有这些之后，我们就能知道，当前为什么出现这样的错误。
<img src="https://gitee.com/HACV/images_bed/raw/master/MainBlog/2020/2020_08/08_08/01.png"></p> <p>图大致分3部分
1.实线---主动发起连接，主动关闭连接（C或S都可能）
2.虚线——被动发起/关闭连接
3.小细线——两端同时操作部分。（同时，我们指的是它发送过来，我接收到了）</p> <p>这个图N多人都知道，它排除和定位网络或系统故障时大有帮助，但是怎样牢牢地将这张图刻在脑中呢？那么你就一定要对这张图的每一个状态，及转换的过程有深刻的认识，不能只停留在一知半解之中。下面对这张图的11种状态详细解析一下，以便加强记忆！
C/S通信过程中，每一个阶段和服务器，它所处于的状态。</p> <ul><li><code>CLOSED</code>：表示初始状态。</li> <li><code>LISTEN</code>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。
<code>SYN_SENT</code>：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</li> <li><code>SYN_RCVD</code>: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</li> <li><code>ESTABLISHED</code>：（三次握手已经完成）表示连接已经建立。</li> <li><code>FIN_WAIT_1</code>:  FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：
FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。
FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。</li> <li><code>FIN_WAIT_2</code>：（主动发起关闭的一端。半关闭完成）主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。</li> <li><code>TIME_WAIT</code>:（主动发起关闭的这端） 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL（我们使用的Linux下，这个时间大概是1分钟左右，等这个的目的是。我饿不确定对方是否能够收到我发送的ACK）后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li> <li><code>CLOSING</code>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li> <li><code>CLOSE_WAIT</code>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</li> <li><code>LAST_ACK</code>: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</li></ul> <p>问题：为啥主动关闭这一端，要设计一个<code>TIME_WAIT</code>状态？
确保最后一个发送的ACK（主动关闭一端的）能够顺利到达。</p> <p>其实，我们也只是了解上面的那些状态中能够被程序捕捉的，因为有的状态，转瞬即逝。</p> <h3 id="（1）2msl-maximum-segment-lifetime"><a href="#（1）2msl-maximum-segment-lifetime" class="header-anchor">#</a> （1）2MSL (Maximum Segment Lifetime)</h3> <p>TIME_WAIT状态的存在有两个理由：</p> <p>（1）让4次握手关闭流程更加可靠；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。<br>
（2）防止lost duplicate对后续新建正常链接的传输造成破坏。lost uplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。</p> <img src="https://gitee.com/HACV/images_bed/raw/master/MainBlog/2020/2020_08/08_08/02.png"> <h3 id="（2）半关闭"><a href="#（2）半关闭" class="header-anchor">#</a> （2）半关闭</h3> <p>RST指的是（标志位，和SYN啥的是对等的，实际上不太会用到，<strong>『RST表示reset』</strong>）</p> <p>从程序的角度，可以使用API来控制实现半连接状态。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> how<span class="token punctuation">)</span><span class="token punctuation">;</span>
sockfd<span class="token operator">:</span> 需要关闭的socket的描述符
how<span class="token operator">:</span>	允许为shutdown操作选择以下几种方式<span class="token operator">:</span>
	<span class="token function">SHUT_RD</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>：	关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。
					该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。
	<span class="token function">SHUT_WR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span>		关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。
	<span class="token function">SHUT_RDWR</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">:</span>	关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD<span class="token punctuation">,</span>然后以SHUT_WR。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="二、端口复用"><a href="#二、端口复用" class="header-anchor">#</a> 二、端口复用</h2> <h3 id="（1）2msl的缺点和解决"><a href="#（1）2msl的缺点和解决" class="header-anchor">#</a> （1）2MSL的缺点和解决</h3> <ul><li><p>缺点：要等2MSL才能释放我用的那个端口号。<br>
虽说不错，但是如果重启，这样维护需要2MSL，但是不方便。</p></li> <li><p>解决方案：那个2MSL需要等1分钟，你继续等待1分钟，但是我们的端口允许我们重复使用。</p></li></ul> <h3 id="（2）用网络的高峰"><a href="#（2）用网络的高峰" class="header-anchor">#</a> （2）用网络的高峰</h3> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>上午	7:30-10:39  
下午	6:30-9:30  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>在server的TCP连接没有完全断开之前不允许重新监听是不合理的</strong>。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:6666）没有完全断开，而我们重新监听的是lis-tenfd（0.0.0.0:6666），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。</p> <p>在server代码的socket()和bind()调用之间插入如下代码：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>int opt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
setsockopt<span class="token punctuation">(</span>listenfd, SOL_SOCKET, SO_REUSEADDR, <span class="token operator">&amp;</span>opt, sizeof<span class="token punctuation">(</span>opt<span class="token punctuation">))</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>有关setsockopt可以设置的其它选项请参考UNP第7章。</p> <h2 id="三、socket错误处理、三次握手、并发"><a href="#三、socket错误处理、三次握手、并发" class="header-anchor">#</a> 三、socket错误处理、三次握手、并发</h2> <ul><li><strong>TCP状态转换图——『最重要』</strong></li></ul> <p>date: 2020-08-07
summary: 简易的多进程和多线程服务器代码</p> <h2 id="四、总览"><a href="#四、总览" class="header-anchor">#</a> 四、总览</h2> <p><strong>（TCP在网络编程当中的地位，相当于你吃饭过程当中，筷子的地位）</strong></p> <ol><li><p>client.c  编写</p></li> <li><p>TCP三次握手建立连接
TCP——不会丢包（错！！！）  丢了可以重传。</p></li> <li><p>MTU、mss、半关闭（这是我们在TCP3次握手中，分支的一些细小的知识）
MTU： 最大传输单元    受协议限制   以太网1500   IP 65535
mss： 受MTU 标示一个数据包携带数据的上限数。
win： 滑动窗口——当前本端 能接收的数据上限值。(单位：字节)</p></li> <li><p>错误处理
read 返回值：</p> <ol><li><blockquote><p>0 实际读到的字节数 buf=1024  1.  == buf 1024   2. &lt; buf  56；</p></blockquote></li> <li><p>= 0 数据读完(读到文件、管道、socket 末尾--对端关闭)</p></li> <li><p>-1  异常</p></li></ol></li> <li><p>errno == EINTR  被信号中断  重启/quit</p></li> <li><p>errno == EAGAIN (EWOULDBLOCK) 非阻塞方式读，并且没有数据</p></li> <li><p>其他值   出现错误。--perror exit。</p></li></ol> <p>比如，自定义函数的封装：虽然标准库中没有提供readn，readline，，但是使用频率高，我们需要自己封装。错误一般思想  Accept</p> <ol start="5"><li>并发服务器模型</li></ol> <blockquote><ul><li>多进程并发（版本）
fork   signal --- sigcation</li> <li>多线程并发
线程分离 detach 。 修改线程属性。</li></ul></blockquote> <p>系统调用不能保证每次都成功，必须进行出错处理，这样一方面可以保证程序逻辑正常，另一方面可以迅速得到故障信息。</p> <p>我们先前，不对各种返回值进行处理，只是为了突出逻辑。</p> <h2 id="五、网络套接字相关函数『记忆』"><a href="#五、网络套接字相关函数『记忆』" class="header-anchor">#</a> 五、网络套接字相关函数『记忆』</h2> <p>借助套接字完成TCP下的C/S模型</p> <h3 id="（1）字节序和主机字节序的转换"><a href="#（1）字节序和主机字节序的转换" class="header-anchor">#</a> （1）字节序和主机字节序的转换</h3> <p>TCP/IP协议规定，网络数据流应采用<strong>大端字节序</strong>，即低地址高字节</p> <blockquote><ul><li>原因，因为TCP/IP最早诞生的时候，几乎是和Unix一块诞生的</li> <li>那个年代，数据存储主要是IBM公司来做，那那时候，他们选用的存储方式都是大端存储法。</li> <li>现在IBM的好多大型机，还是采用的大端法</li> <li>后来，小端法，实际上是在Windows才有的。Intel架构的时候</li> <li>后来在Intel架构上几乎都是用的小端法、</li></ul></blockquote> <p>为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token class-name">uint32_t</span> <span class="token function">htonl</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> hostlong<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">uint16_t</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> hostshort<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">uint32_t</span> <span class="token function">ntohl</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> netlong<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">uint16_t</span> <span class="token function">ntohs</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> netshort<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>h表示host，n表示network，l表示32位长整数，s表示16位短整数。
32位的显然是IP，16位的是端口号。
如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</p> <h3 id="（2）地址转换函数（比1省略了步骤）"><a href="#（2）地址转换函数（比1省略了步骤）" class="header-anchor">#</a> （2）地址转换函数（比1省略了步骤）</h3> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">inet_pton</span><span class="token punctuation">(</span><span class="token keyword">int</span> af<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">inet_ntop</span><span class="token punctuation">(</span><span class="token keyword">int</span> af<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>支持IPv4和IPv6
可重入函数
其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr，还可以转换IPv6的in6_addr。
因此函数接口是void *addrptr。
af表示你选用的IP地址版本。Ipv4和6</p> <p>pton理解：p理解为IP，表示的是我们的字符串的IP，N表示net</p> <p>我们日常生活中大家习惯的IP表现形式是：
比如192.168.1.1这样的点分十进制</p> <p>我们变成
192.168.1.1-》unsigned int类型的数据-》（htonl）网络字节序
Linux发现上面2步太麻烦。现在直接一步
192.168.1.1-——————————————————————》（inet_pton）网络字节序号</p> <h3 id="（3）sockaddr数据结构"><a href="#（3）sockaddr数据结构" class="header-anchor">#</a> （3）sockaddr数据结构</h3> <p>strcut sockaddr <strong>很多网络编程函数诞生早于IPv4协议（强调，理解bind等）</strong>
那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用
传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定
然后函数内部再强制类型转化为所需的地址类型。</p> <blockquote><ul><li>由于，在其中，把结构体sockaddr改为了sockaddr_in结构体，导致编程的时候变麻烦了、</li> <li>特别是这3个函数，他们需要的是sockaddr</li> <li>struct sockaddr_in addr;(定义的时候，要这么定义，原因：sockaddr已经被废弃了，不能用了)</li> <li>bind(,(struct sockaddr*)&amp;addr );</li> <li>accept()</li> <li>connect()</li></ul></blockquote> <p><font size="5" style="background:yellow;">我们现在讲的套接字默认指的是<strong>网络套接字</strong>。注意，我们进程通信的是<strong>本地套接字</strong>，所谓本地套接字就是不使用网络结构呗，不使用IP地址，但是端口号还是得用</font></p> <img src="https://gitee.com/HACV/images_bed/raw/master/MainBlog/2020/2020_08/08_06/01.png"> <p><font size="5" style="background:yellow;">上图可能疑惑点：为什么客户端没有bind呢？难度不需要绑定吗？原因：其实，你如皋没有调用，那么你的操作系统会给你<strong>自动分配</strong>一个端口号和IP地址。</font></p> <p>服务器端，肯定不能自动分配：如果这样，那我的客户端，上<strong>哪里绑定</strong>去2333
其实，客户端也可以bind，但是，我们不绑定的话，我们可以看做（隐式绑定）</p> <p>要想通过socket完成通信，显然我们必须要创建套接字。</p> <h3 id="_1）socket函数（创建套接字）"><a href="#_1）socket函数（创建套接字）" class="header-anchor">#</a> 1）socket函数（创建套接字）</h3> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span> <span class="token comment">/* See NOTES */</span>  <span class="token comment">//显然，如果，你的头文件包含了unixstat这个头文件就包含了</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><ul><li>1）domain:</li></ul> <blockquote><ul><li><code>AF_INET</code>（IPv4） 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址</li> <li><code>AF_INET6</code>（IPv6） 与上面类似，不过是来用IPv6的地址</li> <li><code>AF_UNIX</code>（也就是<strong>本地套接字</strong>） 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</li></ul></blockquote> <ul><li>2）type:（你所选用的socket它内部采用的通信协议是什么？流式，报式协议</li></ul> <blockquote><ul><li><code>SOCK_STREAM</code> 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用<strong>TCP来</strong>进行传输。（流式协议典型代表——TCP）</li> <li><code>SOCK_DGRAM</code> 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用<strong>UDP</strong>来进行它的连接。（报式协议典型代表——UDP）</li> <li><code>SOCK_SEQPACKET</code>该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</li> <li><code>SOCK_RAW</code> socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</li> <li><code>SOCK_RDM</code> 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</li></ul></blockquote> <ul><li>3）protocol:（表示我们选用的协议号是什么，一般默认0，比如流式协议的默认协议是TCP）</li></ul> <blockquote><ul><li>传0 表示使用默认协议。
返回值：
成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</li></ul></blockquote></blockquote> <h3 id="_2）bind函数（绑定，"><a href="#_2）bind函数（绑定，" class="header-anchor">#</a> 2）bind函数（绑定，</h3> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span> <span class="token comment">/* See NOTES */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>sockfd：
socket文件描述符
addr:
构造出IP地址加端口号
addrlen:
sizeof(addr)长度
返回值：
成功返回0，失败返回-1, 设置errno</p> <blockquote><ul><li>服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此<strong>服务器</strong>需要调用bind绑定一个<strong>固定</strong>的<strong>网络地址</strong>和<strong>端口号</strong>。</li></ul></blockquote> <p><font style="background:yellow;">往套接字上绑，往套接字上绑<strong>IP</strong>和<strong>端口号</strong>！！（都放在struct sockaddr这个结构体里面） </font></p> <h3 id="_3）listen函数（指定监听上限数，并不是用来监听的）"><a href="#_3）listen函数（指定监听上限数，并不是用来监听的）" class="header-anchor">#</a> 3）listen函数（指定监听上限数，并不是用来监听的）</h3> <p>（监听，我套接字另外一端给我发送数据？？）
上面是错误的</p> <p><font style="background:yellow;">listen是用来指定<strong>监听上限数</strong>，我只要他来指定一个数值，比如服务器启动起来后，</font></p> <p>指定，<strong>同时</strong>允许多少个客户端和我<strong>建立（强调建立）<strong>连接，（不是指我一共能够</strong>支持</strong>多少个连接）
一旦建立完了，那么就可以继续建立连接。
比如，我们TCP建立连接的3次握手
（比如，我们指定，处于三次握手过程当中的数量，可以是多少个）</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span> <span class="token comment">/* See NOTES */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>sockfd:
socket文件描述符
backlog:
排队建立3次握手队列和刚刚建立3次握手队列的链接数和
查看系统默认backlog
cat /proc/sys/net/ipv4/tcp_max_syn_backlog</p> <p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，<strong>listen()声明sockfd处于监听状态</strong>，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</p> <h3 id="_4）accept函数（这个函数作用，很重要，"><a href="#_4）accept函数（这个函数作用，很重要，" class="header-anchor">#</a> 4）accept函数（这个函数作用，很重要，</h3> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span> 		<span class="token comment">/* See NOTES */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>sockdf:
socket文件描述符
addr:
<strong>传出参数</strong>，返回链接客户端地址信息，含IP地址和端口号
addrlen:
<strong>传入传出参数（函数调用的时候，要传入一个参数，函数调用之后，这个参数要发生改变）</strong>（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小
返回值：
成功返回一个<strong>新的</strong>socket文件描述符（注意是全新的），<strong>用于和客户端通信</strong>，失败返回-1，设置errno</p> <p><strong>三方握手完成后，服务器调用accept()接受连接</strong>，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。</p> <h3 id="_5）connect函数（建立连接，客户端建立连接）"><a href="#_5）connect函数（建立连接，客户端建立连接）" class="header-anchor">#</a> 5）connect函数（建立连接，客户端建立连接）</h3> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span> 					<span class="token comment">/* See NOTES */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>sockdf:
socket文件描述符**（客户端自己建立的socket）**
addr:
传入参数，指定<strong>服务器端</strong>地址信息，含IP地址和端口号
addrlen:
传入参数,传入sizeof(addr)大小
返回值：
成功返回0，失败返回-1，设置errno</p> <p>客户端需要调用connect()连接服务器，connect和bind的参数形式一致
区别在于bind的参数是自己的地址，而connect的参数是对方的地址。connect()成功返回0，出错返回-1。</p> <p>大小写转换</p> <h2 id="六、tcp的两份代码（要倒背如流）"><a href="#六、tcp的两份代码（要倒背如流）" class="header-anchor">#</a> 六、TCP的两份代码（要倒背如流）</h2> <h3 id="（1）服务器代码"><a href="#（1）服务器代码" class="header-anchor">#</a> （1）服务器代码</h3> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXLINE</span> <span class="token expression"><span class="token number">80</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SERV_PORT</span> <span class="token expression"><span class="token number">6666</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> servaddr<span class="token punctuation">,</span> cliaddr<span class="token punctuation">;</span>
	<span class="token class-name">socklen_t</span> cliaddr_len<span class="token punctuation">;</span>
	<span class="token keyword">int</span> listenfd<span class="token punctuation">,</span> connfd<span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> str<span class="token punctuation">[</span>INET_ADDRSTRLEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">,</span> n<span class="token punctuation">;</span>

	listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	servaddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
	servaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>
	servaddr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>SERV_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Accepting connections ...\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		cliaddr_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cliaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>cliaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cliaddr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
		n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;received from %s at PORT %d\n&quot;</span><span class="token punctuation">,</span>
		<span class="token function">inet_ntop</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cliaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token function">ntohs</span><span class="token punctuation">(</span>cliaddr<span class="token punctuation">.</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token function">write</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br></div></div><h3 id="（2）只写了服务器端，如何测试？nc"><a href="#（2）只写了服务器端，如何测试？nc" class="header-anchor">#</a> （2）只写了服务器端，如何测试？nc</h3> <p>问题来了，如果只写了服务器端，如何测试？</p> <p>命令</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">nc</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>nc还有人读脑残。。。（net connect）</p> <p>nc加上你要连接的目标IP的地址，比如说我们本机的127.0.0.1   再加上端口号</p> <p>比如上面的程序，我们可以测试</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">nc</span> <span class="token number">127.0</span>.0.1 <span class="token number">6666</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这样就可以进行</p> <h3 id="（3）客户端代码"><a href="#（3）客户端代码" class="header-anchor">#</a> （3）客户端代码</h3> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXLINE</span> <span class="token expression"><span class="token number">80</span></span></span>

<span class="token comment">//服务器端的端口号！！！！！</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SERV_PORT</span> <span class="token expression"><span class="token number">6666</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> servaddr<span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> n<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">&quot;usage: ./client message\n&quot;</span><span class="token punctuation">,</span> <span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
str <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

	sockfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	servaddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> <span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	servaddr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>SERV_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">write</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Response from server:\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">write</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><p>客户端和服务器启动后可以使用netstat命令查看链接情况：
netstat -apn|grep 6666</p> <p>ARP攻击：针对你当前某一个IP地址，不断的给你发送数据包。
那就当你当前网卡里面读取数据的那个进程给拥塞住。</p> <h2 id="七、错误处理函数（让网络编程程序更加健壮）（错误封装，这种思想很重要）"><a href="#七、错误处理函数（让网络编程程序更加健壮）（错误封装，这种思想很重要）" class="header-anchor">#</a> 七、错误处理函数（让网络编程程序更加健壮）（错误封装，这种思想很重要）</h2> <p>为使错误处理的代码不影响主程序的可读性，我们把与socket相关的一些系统函数加上错误处理代码包装成新的函数，做成一个<strong>模块</strong>wrap.c：<font size="4" style="background:yellow;">（也就是将我们要用到的函数重新进行封装一下，比如说listen啥的）(很好的。可以和主控程序联合编译，方式：你在程序当中要使用的所有系统调用，你都把它重命名一下，函数参数，返回值啥的都不变）</font></p> <p>模块：.c和.h</p> <h2 id="八、『tcp3次握手和4次挥手』"><a href="#八、『tcp3次握手和4次挥手』" class="header-anchor">#</a> 八、『TCP3次握手和4次挥手』</h2> <p>TCP网络协议在传输层
为什么在TCP中要3次握手，究其原因：
和网络层有关，网络层有非常强的不稳定性
因为网络层和硬件联系比较紧密，比如说路由器的宕机或者断电
你的网线or路由器出现问题，都会对IP这一层造成影响。
导致数据不能正常到。</p> <p>所以针对这种网络层不稳定or不安全
传输层：
大概2种处理方法
1）对不稳定的网络层，完全不弥补——能不能接受到，无所谓——UDP，无连接的不可靠**报文（因为有去无回，所以叫报）<strong>传输（有去无回的，我们认为这个数据传输方向是单向的）
2）对不稳定的网络层，做完全弥补。对我们每发的数据包进行记录，发现没有接收到，重发——TCP
面向连接的可靠</strong>数据包（难怪叫包）**传递</p> <p><strong>传输层实际上是为了对我们不稳定的网络层进行弥补操作。</strong></p> <p>TCP是如何保证数据包的可靠传递呢？？和面向连接一词有关系
建立通路
TCP传递，数据包先后经过的路由器是相同的。（当然，，要是其中的路由器断掉了，那么我们两端会重新建立连接，然后重新建立新的线路）。
UDP是不同的</p> <h3 id="（1）tcp通信时序"><a href="#（1）tcp通信时序" class="header-anchor">#</a> （1）TCP通信时序</h3> <p>反正，我觉得谁打的比方叫“握手”？一点都不形象。</p> <img src="https://gitee.com/HACV/images_bed/raw/master/MainBlog/2020/2020_08/08_07/01.png"> <p>1号：1000是序号，不是必须是1000，其中0表示数据包中携带了多少个字节的数据。</p> <img src="https://gitee.com/HACV/images_bed/raw/master/MainBlog/2020/2020_08/08_07/02.png"> <p>问题：发送数据包必须是客户端发一个包，服务器回一个包啊？？
实际上不一定。
如上图，3-9那么多句，发现服务器半天不回，所以我一直发
发现**，客户端你可以连续发多个包，我服务器，直接一条ACK回应你**</p> <h3 id="（2）4次挥手（原因）"><a href="#（2）4次挥手（原因）" class="header-anchor">#</a> （2）4次挥手（原因）</h3> <p>Linux操作系统中，我允许，建立连接的双方有一端关闭连接，但是另一端不关闭。（这种状态，称为<strong>半关闭</strong>）</p> <p>场景：你那边申请结束，我虽然同意，但是我还有部分数据没有传输完，所以，我待会再和你申请，我这边的结束</p> <blockquote><ul><li>疑惑：</li> <li>IP层， 我所能容纳的上限是65535（也就是16bit）（他所能容纳的数据上限是16位数，这个65535是指你网络层，如果我单独把他拎出来，单独看他，他所能够携带的数据上限是65535这么多，但是我们知道，你在网络中传输，你不能单独用IP进行传输，脱离了应用层，传输层，链路层，你根本无法传输到外面，额，这些概念真是坑）</li> <li>以太网，所能容纳的上限是1500
两者的关系，这就涉及到数据包在各个路由器的</li></ul></blockquote> <p>虽然，IP这层设计的时候是有65535那么大，但是他会收到传输层和链路层的夹板，导致我这一个数据包，能不能带这么大的数据？？
不能。比如，他们都比我小，我就要迁就一下他们**（难道，是几个协议封装，像板子，弄成筒子，短板效应？？对的，这个理解很好）**</p> <p>同理，所以最后受到限制的就是以太网（链路层？？），他默认就能传，1500
所以，虽然你IP层可以那么大，但是由于“木桶效应”，所以不能那么大。</p> <p>其实，我们的以太网的数据包的大小，1500是符合我们日常的
我们经常只是几KB的，所以说，1，2个数据包就过去了。
所以，也没有必要把这个设计很大。</p> <p>TCP还是会丢包，只是丢包，可以重传。
UDP的话，丢包了就丢包了。</p> <h3 id="（3）mtu（最大传输单元）"><a href="#（3）mtu（最大传输单元）" class="header-anchor">#</a> （3）MTU（最大传输单元）</h3> <ul><li>通信术语： <strong>最大传输单元</strong>（Maximum Transmission Unit，MTU）</li></ul> <p>是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。从上面的MTU，我们引出了——<strong>最大传输大小mss</strong></p> <h3 id="（4）滑动窗口"><a href="#（4）滑动窗口" class="header-anchor">#</a> （4）滑动窗口</h3> <ul><li>(TCP流量控制)</li></ul> <p>介绍UDP时我们描述了这样的问题：如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会丢失数据。</p> <p>UDP中有没有，滑动窗口这样的东西呢？因为我们知道，滑动窗口是在TCP数据包中记录的，但是UDP协议中，没有描述窗口这件事。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.1fba1c74.js" defer></script><script src="/assets/js/43.7a79755c.js" defer></script>
  </body>
</html>
