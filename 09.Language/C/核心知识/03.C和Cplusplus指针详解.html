<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C语言指针详解 | HACV</title>
    <meta name="description" content="Personal Blog Website">
    <link rel="icon" href="/images/photo.jpg">
  <link rel="manifest" href="/images/photo.jpg">
  <link rel="apple-touch-icon" href="/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.0dbae9ec.css" as="style"><link rel="preload" href="/assets/js/app.8446f194.js" as="script"><link rel="preload" href="/assets/js/83.125aa7a6.js" as="script"><link rel="prefetch" href="/assets/js/10.a6bbc050.js"><link rel="prefetch" href="/assets/js/100.9f2a5bb9.js"><link rel="prefetch" href="/assets/js/101.b8294891.js"><link rel="prefetch" href="/assets/js/102.837529c6.js"><link rel="prefetch" href="/assets/js/103.fae13d89.js"><link rel="prefetch" href="/assets/js/104.0d69046c.js"><link rel="prefetch" href="/assets/js/105.df634581.js"><link rel="prefetch" href="/assets/js/106.4e313408.js"><link rel="prefetch" href="/assets/js/107.f09d6f80.js"><link rel="prefetch" href="/assets/js/108.c5a78d87.js"><link rel="prefetch" href="/assets/js/109.17561c0d.js"><link rel="prefetch" href="/assets/js/11.eb9ab5cc.js"><link rel="prefetch" href="/assets/js/110.484f9926.js"><link rel="prefetch" href="/assets/js/111.e1e3ad65.js"><link rel="prefetch" href="/assets/js/112.6e679887.js"><link rel="prefetch" href="/assets/js/113.17eb3bcb.js"><link rel="prefetch" href="/assets/js/12.d6910e25.js"><link rel="prefetch" href="/assets/js/13.e3ed9d1c.js"><link rel="prefetch" href="/assets/js/14.624d1261.js"><link rel="prefetch" href="/assets/js/15.a5486801.js"><link rel="prefetch" href="/assets/js/16.fab0c1dc.js"><link rel="prefetch" href="/assets/js/17.ea415e2f.js"><link rel="prefetch" href="/assets/js/18.882ca7ae.js"><link rel="prefetch" href="/assets/js/19.5deed5a1.js"><link rel="prefetch" href="/assets/js/2.b5e831f0.js"><link rel="prefetch" href="/assets/js/20.b9cfec59.js"><link rel="prefetch" href="/assets/js/21.571eda40.js"><link rel="prefetch" href="/assets/js/22.c7f3bcfd.js"><link rel="prefetch" href="/assets/js/23.4a3796c2.js"><link rel="prefetch" href="/assets/js/24.6d1e9703.js"><link rel="prefetch" href="/assets/js/25.eb2c8c89.js"><link rel="prefetch" href="/assets/js/26.0318e334.js"><link rel="prefetch" href="/assets/js/27.e8dcdeb9.js"><link rel="prefetch" href="/assets/js/28.92b676cb.js"><link rel="prefetch" href="/assets/js/29.427c63e8.js"><link rel="prefetch" href="/assets/js/3.c95a7970.js"><link rel="prefetch" href="/assets/js/30.9c247d56.js"><link rel="prefetch" href="/assets/js/31.ba36ec25.js"><link rel="prefetch" href="/assets/js/32.8ecaf164.js"><link rel="prefetch" href="/assets/js/33.7ad93c04.js"><link rel="prefetch" href="/assets/js/34.4d5acfed.js"><link rel="prefetch" href="/assets/js/35.bc453caa.js"><link rel="prefetch" href="/assets/js/36.74290cc7.js"><link rel="prefetch" href="/assets/js/37.a34af39c.js"><link rel="prefetch" href="/assets/js/38.e49755b7.js"><link rel="prefetch" href="/assets/js/39.3937cd65.js"><link rel="prefetch" href="/assets/js/4.de977804.js"><link rel="prefetch" href="/assets/js/40.173b9248.js"><link rel="prefetch" href="/assets/js/41.b0a63d3e.js"><link rel="prefetch" href="/assets/js/42.b01c537c.js"><link rel="prefetch" href="/assets/js/43.543a2d12.js"><link rel="prefetch" href="/assets/js/44.cf3404d3.js"><link rel="prefetch" href="/assets/js/45.9d31fa53.js"><link rel="prefetch" href="/assets/js/46.ad02cb0b.js"><link rel="prefetch" href="/assets/js/47.49734164.js"><link rel="prefetch" href="/assets/js/48.4c771f67.js"><link rel="prefetch" href="/assets/js/49.66b1543d.js"><link rel="prefetch" href="/assets/js/5.f8a45d7a.js"><link rel="prefetch" href="/assets/js/50.9f5600e7.js"><link rel="prefetch" href="/assets/js/51.fc3ab9f1.js"><link rel="prefetch" href="/assets/js/52.b3410e3c.js"><link rel="prefetch" href="/assets/js/53.aaf959b6.js"><link rel="prefetch" href="/assets/js/54.c7bb7881.js"><link rel="prefetch" href="/assets/js/55.2323e54c.js"><link rel="prefetch" href="/assets/js/56.7d391f13.js"><link rel="prefetch" href="/assets/js/57.7265ee2f.js"><link rel="prefetch" href="/assets/js/58.eb07ee01.js"><link rel="prefetch" href="/assets/js/59.56f1cfc7.js"><link rel="prefetch" href="/assets/js/6.5b891f58.js"><link rel="prefetch" href="/assets/js/60.6b6fff84.js"><link rel="prefetch" href="/assets/js/61.5e2f8e8c.js"><link rel="prefetch" href="/assets/js/62.65d8ca18.js"><link rel="prefetch" href="/assets/js/63.b590e378.js"><link rel="prefetch" href="/assets/js/64.6b75246f.js"><link rel="prefetch" href="/assets/js/65.6ab405ee.js"><link rel="prefetch" href="/assets/js/66.420adbce.js"><link rel="prefetch" href="/assets/js/67.9c363a2f.js"><link rel="prefetch" href="/assets/js/68.c5c19ac4.js"><link rel="prefetch" href="/assets/js/69.caddf237.js"><link rel="prefetch" href="/assets/js/7.377da0f5.js"><link rel="prefetch" href="/assets/js/70.927f342d.js"><link rel="prefetch" href="/assets/js/71.90ea7933.js"><link rel="prefetch" href="/assets/js/72.d5fff903.js"><link rel="prefetch" href="/assets/js/73.aca5c73e.js"><link rel="prefetch" href="/assets/js/74.1412d7b1.js"><link rel="prefetch" href="/assets/js/75.f57101dd.js"><link rel="prefetch" href="/assets/js/76.9bd1b503.js"><link rel="prefetch" href="/assets/js/77.cc043b81.js"><link rel="prefetch" href="/assets/js/78.8c58b2b7.js"><link rel="prefetch" href="/assets/js/79.e8ff0a55.js"><link rel="prefetch" href="/assets/js/8.4f159108.js"><link rel="prefetch" href="/assets/js/80.bd5e1efd.js"><link rel="prefetch" href="/assets/js/81.96f7e280.js"><link rel="prefetch" href="/assets/js/82.de5093dc.js"><link rel="prefetch" href="/assets/js/84.9c2cfcc6.js"><link rel="prefetch" href="/assets/js/85.720135cf.js"><link rel="prefetch" href="/assets/js/86.7fa2209a.js"><link rel="prefetch" href="/assets/js/87.28121f09.js"><link rel="prefetch" href="/assets/js/88.efca3faa.js"><link rel="prefetch" href="/assets/js/89.e73a901a.js"><link rel="prefetch" href="/assets/js/9.3cde5a93.js"><link rel="prefetch" href="/assets/js/90.07b2ac07.js"><link rel="prefetch" href="/assets/js/91.c314631a.js"><link rel="prefetch" href="/assets/js/92.f2ab4cda.js"><link rel="prefetch" href="/assets/js/93.d5780490.js"><link rel="prefetch" href="/assets/js/94.bb6af73b.js"><link rel="prefetch" href="/assets/js/95.ef775615.js"><link rel="prefetch" href="/assets/js/96.edb6ebb1.js"><link rel="prefetch" href="/assets/js/97.a4f8279c.js"><link rel="prefetch" href="/assets/js/98.8bfc62dd.js"><link rel="prefetch" href="/assets/js/99.1b5881a8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0dbae9ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">HACV</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">⭐️硬件</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">🔋软件</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></li><li class="dropdown-item"><!----> <a href="/03.OS/" class="nav-link">💻操作系统</a></li><li class="dropdown-item"><!----> <a href="/04.Net/" class="nav-link">☁️计算机网络</a></li><li class="dropdown-item"><!----> <a href="/05.SE/" class="nav-link">✅软件工程</a></li></ul></div></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">⚡️数据库</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">⚙️工具</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">🚀语言</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/09.Language/C/" class="nav-link router-link-active">⭐️C</a></li><li class="dropdown-item"><!----> <a href="/09.Language/Cpp/" class="nav-link">🚀C++</a></li><li class="dropdown-item"><!----> <a href="/09.Language/Java/" class="nav-link">☕️Java</a></li></ul></div></div><div class="nav-item"><a href="/10.SourceCode/" class="nav-link">⭐️源码剖析</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">⭐️硬件</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">🔋软件</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></li><li class="dropdown-item"><!----> <a href="/03.OS/" class="nav-link">💻操作系统</a></li><li class="dropdown-item"><!----> <a href="/04.Net/" class="nav-link">☁️计算机网络</a></li><li class="dropdown-item"><!----> <a href="/05.SE/" class="nav-link">✅软件工程</a></li></ul></div></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">⚡️数据库</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">⚙️工具</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">🚀语言</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/09.Language/C/" class="nav-link router-link-active">⭐️C</a></li><li class="dropdown-item"><!----> <a href="/09.Language/Cpp/" class="nav-link">🚀C++</a></li><li class="dropdown-item"><!----> <a href="/09.Language/Java/" class="nav-link">☕️Java</a></li></ul></div></div><div class="nav-item"><a href="/10.SourceCode/" class="nav-link">⭐️源码剖析</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>C语言指针详解</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#📑目录" class="sidebar-link">📑目录</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_01-指针的几个『核心概念』" class="sidebar-link">01.指针的几个『核心概念』</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_02-指针常量和常量指针和顶层-底层const" class="sidebar-link">02.指针常量和常量指针和顶层/底层const</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_2-1-c-primer中有顶层-底层const说法✔️" class="sidebar-link">2.1.C++primer中有顶层/底层const说法✔️</a></li><li class="sidebar-sub-header"><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_2-2-指针常量和常量指针『说法好像是民科』✔️" class="sidebar-link">2.2.指针常量和常量指针『说法好像是民科』✔️</a></li></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#✅核心" class="sidebar-link">✅核心</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#前言：复杂类型说明" class="sidebar-link">前言：复杂类型说明</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#t-1-指针相关优先级" class="sidebar-link">t.1.指针相关优先级</a></li><li class="sidebar-sub-header"><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#t2-目前考过本部分知识的公司" class="sidebar-link">t2.目前考过本部分知识的公司</a></li></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_01-细说指针" class="sidebar-link">01.细说指针</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_1-1-指针的类型" class="sidebar-link">1.1.指针的类型</a></li><li class="sidebar-sub-header"><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_1-2-指针所指向的类型『和步长有关』" class="sidebar-link">1.2.指针所指向的类型『和步长有关』</a></li><li class="sidebar-sub-header"><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_1-3-指针的值—或者叫指针所指向的内存区或地址『注意和前面的区别，很重要』" class="sidebar-link">1.3.指针的值—或者叫指针所指向的内存区或地址『注意和前面的区别，很重要』</a></li><li class="sidebar-sub-header"><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_1-4-指针本身所占据的内存区" class="sidebar-link">1.4.指针本身所占据的内存区</a></li></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_02-指针的算术运算" class="sidebar-link">02.指针的算术运算</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_03-运算符-和" class="sidebar-link">03.运算符&amp;和*</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_04-指针表达式『重要，还有左值』" class="sidebar-link">04.指针表达式『重要，还有左值』</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_05-数组和指针的关系" class="sidebar-link">05.数组和指针的关系</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_06-指针和结构类型的关系" class="sidebar-link">06.指针和结构类型的关系</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_07-指针和函数的关系ok" class="sidebar-link">07.指针和函数的关系OK</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_08-指针类型转换" class="sidebar-link">08.指针类型转换</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_09-指针的安全问题" class="sidebar-link">09.指针的安全问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/C/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/03.C%E5%92%8CCplusplus%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3.html#_10-结束语" class="sidebar-link">10.结束语</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="c语言指针详解"><a href="#c语言指针详解" class="header-anchor">#</a> C语言指针详解</h1> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>&lt;font style=&quot;background:yellow&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="📑目录"><a href="#📑目录" class="header-anchor">#</a> 📑目录</h2> <p>[TOC]</p> <h2 id="_01-指针的几个『核心概念』"><a href="#_01-指针的几个『核心概念』" class="header-anchor">#</a> 01.指针的几个『核心概念』</h2> <ul><li>指针的类型『用途：如malloc前的强制类型转换』</li> <li>指针所指向的类型</li> <li>指针所指向的内存区</li> <li>指针的『<strong>步长</strong>』</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>i<span class="token punctuation">;</span>
    p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>e<span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">9</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>
    
    
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d &quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>有人的讲解不错：</p> <p><strong>指针的步长与指针的类型相关</strong>，由于p为int型指针，故<code>p+i表示跳过i个int长度；</code></p> <p>指针步长的核心经验</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> aa<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//aa是个int * const aaPtr= &amp;aa[0];</span>
<span class="token comment">//aa是个本身不能变的（也就是指向不能变）的指针，但是指向的对象它本身可变</span>
<span class="token comment">//『+1』的步长是一个int『4字节』</span>

<span class="token keyword">auto</span> ptr<span class="token operator">=</span><span class="token operator">&amp;</span>aa<span class="token punctuation">;</span>
<span class="token comment">//类型是下面的，数组指针</span>
<span class="token comment">//『+1』的步长是5个int『20个字节』</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">&amp;</span>aa<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_02-指针常量和常量指针和顶层-底层const"><a href="#_02-指针常量和常量指针和顶层-底层const" class="header-anchor">#</a> 02.<code>指针常量</code>和<code>常量指针</code>和<code>顶层/底层const</code></h2> <h3 id="_2-1-c-primer中有顶层-底层const说法✔️"><a href="#_2-1-c-primer中有顶层-底层const说法✔️" class="header-anchor">#</a> 2.1.C++primer中有<code>顶层/底层const</code>说法✔️</h3> <blockquote><p>《C++ Primer》</p></blockquote> <ul><li><strong>顶层</strong>const『top-level const』：表示<code>指针本身</code>是个常量</li> <li><strong>底层</strong>const『low-level const』：表示<font style="background:yellow;">『指针指向的对象』</font>是个常量</li></ul> <blockquote><p>记忆方式：</p></blockquote> <ul><li>顶层const可以表示<strong>任意的对象</strong>是常量，这1点对任何数据类型都适用</li> <li>底层const则与『指针』和『引用』等复合类型的基本类型部分有关。</li></ul> <h3 id="_2-2-指针常量和常量指针『说法好像是民科』✔️"><a href="#_2-2-指针常量和常量指针『说法好像是民科』✔️" class="header-anchor">#</a> 2.2.指针常量和常量指针『说法好像是民科』✔️</h3> <ul><li>参考：<a href="http://c.biancheng.net/view/1476.html" target="_blank" rel="noopener noreferrer">C语言中文网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，说法和下面一致</li></ul> <blockquote><p>语文：常量指针和指针常量</p></blockquote> <ul><li>1、看见<code>const</code>读作『常量』</li> <li>2、看见<code>*</code>读作『指针』</li> <li>3、以<code>*</code>为界限，const放左边和右边，『可以读出2种方式』</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> p1<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//常量指针</span>
<span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span> p2<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//常量指针『和上面等价』</span>

<span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p3<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//指针常量，显然是『顶层const』</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>常量指针和指针常量的语文意义：</li> <li>前面的是『形容词』，后边的是『名词』
<ul><li>常量指针：本质是指针，只不过是常量指针，表示指针<code>所指的对象</code>是个常量</li> <li>指针常量：本质是常量，只不过是指针常量，表示<code>指针本身</code>不能变，也就是『指向』不能变</li></ul></li></ul> <blockquote><p>核心：<font style="background:yellow;">搞清楚，『指针本身』和『指针指向的对象』</font></p></blockquote> <ul><li><p>记忆方式：</p> <ul><li>常量指针：本质是指针，形容词是『常量』，表示『指针指向的对象』不能变</li> <li>指针常量：本质是常量，形容词是『指针』，表示『指针本身』不能变</li></ul></li></ul> <blockquote><p>Q：数组的『数组名』是常量指针还是指针常量呢？</p></blockquote> <ul><li>A：由于数组名，它的指向不能变，转换过来的意思是：<font style="background:yellow;">『指针本身不可变』</font></li> <li>所以是『指针常量』</li></ul> <h2 id="✅核心"><a href="#✅核心" class="header-anchor">#</a> ✅核心</h2> <ul><li>✅转载和修订《指针详解》</li> <li>参考自：公众号『C语言与程序设计』——关于指针，你想要的都在这里了</li></ul> <h2 id="前言：复杂类型说明"><a href="#前言：复杂类型说明" class="header-anchor">#</a> 前言：复杂类型说明</h2> <h3 id="t-1-指针相关优先级"><a href="#t-1-指针相关优先级" class="header-anchor">#</a> t.1.指针相关优先级</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>运算符				结合性
<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  			从左边到右边
<span class="token operator">*</span> <span class="token operator">&amp;</span> <span class="token keyword">sizeof</span>  	从右边到左边
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="t2-目前考过本部分知识的公司"><a href="#t2-目前考过本部分知识的公司" class="header-anchor">#</a> t2.目前考过本部分知识的公司</h3> <blockquote><p>来自牛客网数据</p></blockquote> <ul><li>恒生电子</li> <li>深信服</li> <li>4399</li></ul> <p>要了解指针,多多少少会出现一些比较复杂的类型,所以我先介绍一下<strong>如何 完全理解一个复杂类型</strong>,要理解复杂类型其实很简单,一个类型里会出现很多运 算符,他们也像普通的表达式一样,有<strong>优先级</strong>,其优先级和运算优先级一样,所以 我总结了一下其原则:</p> <ul><li><font style="background:yellow;"> 从变量名处起,根据运算符优先级结合,一步一步分析.</font></li></ul> <p>下面让我们先从简单的类型开始慢慢分析吧:</p> <ul><li><code>int p;</code> //这是一个普通的整型变量</li> <li><code>int *p;</code> <ul><li>//首先从 P 处开始,先与<code>*</code>结合,所以说明 P 是一个指针,</li> <li>然后再与 <code>int</code> 结合,说明指针所指向的内容的类型为 int 型.所以 P 是一个返回整型数据的指针</li></ul></li> <li><code>int p[3];</code> <ul><li>//首先从 P 处开始,先与<code>[]</code>结合,说明 P 是一个数组,</li> <li>然后 与 <code>int</code> 结合,说明数组里的元素是整型的,所以 P 是一个 由整型数据组成的数组</li></ul></li> <li><code>int *p[3]</code> <ul><li>//首先从宏观P开始，先与<code>[]</code>结合，因为其优先级比<code>*</code>高,所以 P 是一个数组,</li> <li>然后再与<code>*</code>结合,说明数组里的元素是指针类型,</li> <li>然后再与 <code>int</code> 结合,说明指针所指向的内容的类型是整型的,</li> <li>所以P 是一个由返回整型数据的指针所组成的数组</li></ul></li> <li><code>int (*p)[3];</code> <ul><li>//首先从 P 处开始,先与<code>*</code>结合,说明 P 是一个指针</li> <li>然后再与<code>[]</code>结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,</li> <li>然后再与<code>int</code>结合,说明 数组里的元素是整型的.所以 P 是一个指向由整型数据组 成的数组的指针</li></ul></li> <li><code>int **p;</code> <ul><li>//首先从P开始,先与<code>*</code>结合,说是 P 是一个指针,</li> <li>然后再与<code>*</code>结合,说明指针所指向的元素是指针,</li> <li>然后再与<code>int</code>结合,说 明该指针所指向的元素是整型数据.</li> <li>由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我 们就不考虑多级指针了,最多只考虑一级指针.</li></ul></li> <li><code>int p(int);</code> <ul><li>//从 P 处起,先与<code>（）</code>结合,说明 P 是一个函数,</li> <li>然后进入（） 里分析,说明该函数有一个整型变量的参数</li> <li>然后再与外面的 int 结合,说明函数的返回值是一个整型数据。</li></ul></li> <li><code>int (*p)(int);</code> <ul><li>//从P 处开始,先与指针结合,说明 P 是一个指针,</li> <li>然后与<code>()</code>结合,说明指针指向的是一个函数,</li> <li>然后再与()里的int 结合,说明函数有一个 int 型的参数,</li> <li>再与最外层的int 结 合,说明函数的返回类型是整型,所以 P 是一个指向有一个 整型参数且返回类型为整型的函数的指针</li></ul></li> <li><code>int *(*p(int))[3];</code>『<font style="background:yellow;">//可以先跳过,不看这个类型,过于复杂</font>』
<ul><li>//从 P 开始,先与<code>()</code>结合,说明 P 是一个函数,</li> <li>然后进入()里 面,与 int 结合,说明函数有一个整型变量参数,</li> <li>然后再与外面 的<code>*</code>结合,说明函数返回的是一个指针,</li> <li>然后到最外面一层,先与<code>[]</code>结合,说明返回的指针指向的是一个数组,</li> <li>然后再与<code>*</code>结合,说明数组里的元素是指针,</li> <li>然后再与 <code>int</code> 结合,说明指针指向的内容是整型数据.所以 P 是一个参数为一个整数据且返回 一个指向由整型指针变量组成的数组的指针变量的函数.</li></ul></li></ul> <p>说到这里也就差不多了,我们的任务也就这么多,理解了这几个类型, 其它的类型对我们来说也是小菜了,不过我们一般不会用太复杂的类型,那样会大大减小程序的可读性,请慎用,这上面的几种类型已经足够我们用 了.</p> <h2 id="_01-细说指针"><a href="#_01-细说指针" class="header-anchor">#</a> 01.细说指针</h2> <p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：</p> <ul><li>指针的类型</li> <li>指针所指向的类型</li> <li>指针的值或者叫指针所指向的内存区</li> <li>指针本身所占据的内存区</li></ul> <p>让我们分别说明。 先声明几个指针放着做例子：</p> <p>例一：</p> <ul><li><p>(1)<code>int * ptr</code></p></li> <li><p>(2)<code>char * ptr;</code></p></li> <li><p>(3)<code>int * * ptr;</code></p></li> <li><p>(4)<code>int(*ptr)[3];</code></p></li> <li><p>(5)<code>int*(*ptr)[4];</code></p></li></ul> <h3 id="_1-1-指针的类型"><a href="#_1-1-指针的类型" class="header-anchor">#</a> 1.1.指针的类型</h3> <p>从语法的角度看，<font style="background:yellow;">你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。</font>这是指针本身所具有的类型。让我们看看例一中各 个指针的类型：</p> <ul><li><p>(1)<code>int * ptr; //指针的类型是 int*</code></p></li> <li><p>(2)<code>char * ptr; //指针的类型是 char*</code></p></li> <li><p>(3)<code>int * * ptr; //指针的类型是 int**</code></p></li> <li><p>(4)<code>int(*ptr)[3]; //指针的类型是 int(*)[3]</code></p></li> <li><p>(5)<code>int*(*ptr)[4]; //指针的类型是 int*(*)[4]</code></p></li></ul> <p>怎么样？找出指针的类型的方法是不是很简单？</p> <h3 id="_1-2-指针所指向的类型『和步长有关』"><a href="#_1-2-指针所指向的类型『和步长有关』" class="header-anchor">#</a> 1.2.指针所指向的类型『和步长有关』</h3> <p>​	当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p> <p>​	从语法上看，你只须<font style="background:yellow;">把指针声明语句中的指针名字和名字左边的指针声明符<code>*</code>去掉，剩下的就是指针所指向的类型。</font></p> <p>例如：</p> <ul><li><p>(1)<code>int * ptr; //指针所指向的类型是int</code></p></li> <li><p>(2)<code>char * ptr; //指针所指向的类型是char *</code></p></li> <li><p>(3)<code>int * * ptr; //指针所指向的类型是int *</code></p></li> <li><p>(4)<code>int(*ptr)[3]; //指针所指向的类型是int ()[3]</code></p></li> <li><p>(5)<code>int*(*ptr)[4]; //指针所指向的类型是int *()[4]</code></p></li></ul> <p>重点来了：</p> <ul><li><font style="background:yellow;">在指针的<strong>算术运算</strong>中，指针所指向的类型有很大的作用。『注： 指针的『<strong>步长</strong>』』</font></li> <li>指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。</li></ul> <p>当你对C 越来越熟悉时，你会发现，把与指针搅和在一起的&quot;类型&quot;这个概念分成 &quot;指针的类型&quot;和&quot;指针所指向的类型&quot;两个概念，是<strong>精通指针的关键点之一</strong>。 我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了， 所以看起书来前后矛盾，越看越糊涂。</p> <h3 id="_1-3-指针的值—或者叫指针所指向的内存区或地址『注意和前面的区别，很重要』"><a href="#_1-3-指针的值—或者叫指针所指向的内存区或地址『注意和前面的区别，很重要』" class="header-anchor">#</a> 1.3.指针的值—或者叫指针所指向的内存区或地址『注意和前面的区别，很重要』</h3> <p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而 不是一个一般的数值。</p> <ul><li><p>在 32 位程序里，所有类型的指针的值都是一个 32 位整数，因为 32 位程序里内存地址全都是 32 位长。</p></li> <li><p><font style="background:yellow;">『指针所指向的内存区』就是从<strong>指针的值</strong>所代表的那个内存地址<strong>开始</strong>，长度为**sizeof(指针所指向的类型)**的一片内存区。</font></p></li> <li><p>以后，我们说一个指针的值是 XX，就相当于说该指针指向了以 XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域， 就相当于说该指针的值是这块内存区域的<strong>首地址</strong>。</p></li> <li><p><font style="background:yellow;">『<strong>指针所指向的内存区</strong>』和『<strong>指针所指向的类型</strong>』是两个完全不同的概念。</font></p></li> <li><p><strong>易错点</strong>：<font style="background:yellow;">在例一中，指针所指向的类型已经有了，但由于<strong>指针还未初始化</strong>，所以它所指向的内存区是不存在的，或者说是<strong>无意义</strong>的。</font></p></li></ul> <p>以后，每遇到一个指针，都应该问问：</p> <ul><li>这个指针的类型是什么？</li> <li>指针指的类型是什么？</li> <li>该指针指向了哪里？（重点注意）</li></ul> <h3 id="_1-4-指针本身所占据的内存区"><a href="#_1-4-指针本身所占据的内存区" class="header-anchor">#</a> 1.4.指针本身所占据的内存区</h3> <p>指针本身占了多大的内存？</p> <p>你只要用函数sizeof(指针的类型)测一下就知道了。在 32 位平台里，指针本身占据了 4 个字节的长度</p> <ul><li><font style="background:yellow;">指针本身占据的内存这个概念在判断一个<strong>指针表达式</strong>（后面会解释）是否是<strong>左值</strong>时很有用。</font></li></ul> <h2 id="_02-指针的算术运算"><a href="#_02-指针的算术运算" class="header-anchor">#</a> 02.指针的算术运算</h2> <ul><li>指针可以加上或减去一个整数。</li> <li><font style="background:yellow;">指针的这种运算的意义<strong>和通常的数值的加减运算的意义是不一样</strong>的，以<strong>单元</strong>为单位</font></li></ul> <p>例如：</p> <p>例二：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span> <span class="token comment">//强制类型转换并不会改变a的类型</span>
ptr<span class="token operator">++</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上例中，指针 ptr 的类型是 <code>int*</code>,它指向的类型是<code>int</code>，它被初始化为指向整型变量 a。</p> <ul><li>接下来的<font style="background:yellow;">第 3 句中，指针ptr被加了1，编译器是这样处理的：它把指针 ptr 的值加上了<code>sizeof(int)</code>，在 32 位程序中，是被加上了 4，因为在 32 位程序中，int 占 4 个字节。</font>由于地址是用字节做单位的， 故 ptr 所指向的地址由原来的变量 a 的地址向高地址方向增加了 4 个字节。 由于 char 类型的长度是一个字节，所以，原来 ptr 是指向数组 a 的第 0 号 单元开始的四个字节，此时指向了数组 a 中从第 4 号单元开始的四个字节。</li> <li>我们可以用一个指针和一个循环来遍历一个数组，看例子：</li></ul> <p>例三：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token operator">=</span>array<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
    ptr<span class="token operator">++</span>；
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这个例子将整型数组中各个单元的值加 1。由于每次循环都将指针ptr <strong>加 1 个单元</strong>，所以每次循环都能访问数组的下一个单元。</p> <p>再看例子：</p> <p>例四：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">&quot;You_are_a_girl&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>
ptr<span class="token operator">+=</span><span class="token number">5</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>在这个例子中，ptr 被加上了 5，编译器是这样处理的：将指针 ptr 的 值加上 5 乘 <code>sizeof(int)</code>，在 32 位程序中就是加上了 5 乘 4=20。</li></ul> <p>由于地址 的单位是字节，故现在的 ptr 所指向的地址比起加 5 后的 ptr 所指向的地址 来说，向高地址方向移动了 20 个字节。在这个例子中，没加 5 前的 ptr 指 向数组 a 的第 0 号单元开始的四个字节，加 5 后，ptr 已经指向了数组 a 的 合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。 这也体现出了指针的灵活性。</p> <p>如果上例中，ptr 是被减去 5，那么处理过程大同小异，只不过 ptr 的 值是被减去 5 乘 sizeof(int)，新的 ptr 指向的地址将比原来的 ptr 所指向 的地址向低地址方向移动了 20 个字节。</p> <p>下面请允许我再举一个例子:(一个误区)</p> <p>例五：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">&quot; You_are_a_girl&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span>a<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token operator">&amp;</span>p<span class="token punctuation">;</span>
    
    <span class="token comment">//printf(&quot;p=%d\n&quot;,p);</span>
    <span class="token comment">//printf(&quot;ptr=%d\n&quot;,ptr);</span>
    <span class="token comment">//printf(&quot;*ptr=%d\n&quot;,*ptr);</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;**ptr=%c\n&quot;</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    ptr<span class="token operator">++</span><span class="token punctuation">;</span>
    
    <span class="token comment">//printf(&quot;ptr=%d\n&quot;,ptr);</span>
    <span class="token comment">//printf(&quot;*ptr=%d\n&quot;,*ptr);</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;**ptr=%c\n&quot;</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li>误区一、输出答案为 Y 和 o
<ul><li>误解:ptr 是一个 char 的二级指针,当执行<code>ptr++</code>;时,会使指针加一个<code>sizeof(char)</code>,所以输出如上结果,这个可能只是少部分人的结果.</li></ul></li> <li>误区二、输出答案为 Y 和 a
<ul><li>误解:ptr 指向的是一个 <code>char *</code>类型,当执行 <code>ptr++;</code>时,会使指针加一个<code>sizeof(char *)</code>(有可能会有人认为这个值为1,那就会得到误区一的答案,这个值应该是 4,参考前面内容), 即<code>&amp;p+4;</code> 那进行一次取值运算不就指向数组中的第五个元素了吗?那输出的结果不就是数组中第五个元 素了吗?答案是否定的.</li></ul></li> <li>正解:
<ul><li>ptr 的类型是<code>char **</code>,指向的类型是一个 <code>char *</code>类型,该指向的地址就是p的地址(&amp;p),当执行<code>ptr++;</code>时,会使指针加一个<code>sizeof(char *)</code>,即<code>&amp;p+4</code>;那<code>*(&amp;p+4)</code>指向哪呢,这个你去问上帝吧,或者他会告诉你在哪?所以最后的输出会是一个随机的值,或许是一个非法操作.</li></ul></li> <li>总结一下:
<ul><li>一个指针<code>ptrold</code>加(减)一个整数 n 后，结果是一个新的指针<code>ptrnew</code></li> <li>ptrnew的类型和ptrold 的类型相同，ptrnew 所指向的类型和 ptrold 所指向的类型也相同。ptrnew的值将比 ptrold 的值增加(减少)了 n 乘<code>sizeof(ptrold 所指向的类型)</code>个字节。</li></ul></li> <li>指针和指针进行加减：
<ul><li>两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的 结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组方面，不多说了</li></ul></li></ul> <h2 id="_03-运算符-和"><a href="#_03-运算符-和" class="header-anchor">#</a> 03.运算符<code>&amp;</code>和<code>*</code></h2> <p>这里<code>&amp;</code>是取地址运算符，<code>*</code>是间接运算符。</p> <ul><li><p><code>&amp;a</code>的运算结果是一个指针，指针的类型是 a 的类型加个<code>*</code>，指针所 指向的类型是 a 的类型，指针所指向的地址嘛，那就是 a 的地址。</p></li> <li><p><code>*p</code> 的运算结果就五花八门了。总之<code>*p</code> 的结果是 p 所指向的东西， 这个东西有这些特点：它的类型是 p 指向的类型，它所占用的地址是 p 所指向的地址。</p></li></ul> <p>例六：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token punctuation">;</span>

p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">//&amp;a 的结果是一个指针，类型是 int*，指向的类型是</span>
	<span class="token comment">//int，指向的地址是 a 的地址。</span>

<span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">24</span><span class="token punctuation">;</span> <span class="token comment">//*p 的结果，在这里它的类型是 int，它所占用的地址是</span>
	<span class="token comment">//p 所指向的地址，显然，*p 就是变量 a。</span>

ptr<span class="token operator">=</span><span class="token operator">&amp;</span>p<span class="token punctuation">;</span> <span class="token comment">//&amp;p 的结果是个指针，该指针的类型是 p 的类型加个*，</span>
	<span class="token comment">//在这里是 int **。该指针所指向的类型是 p 的类型，这</span>
	<span class="token comment">//里是 int*。该指针所指向的地址就是指针 p 自己的地址。</span>

<span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment">//*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针</span>
	<span class="token comment">//的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋</span>
	<span class="token comment">//值就是毫无问题的了。</span>

<span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token number">34</span><span class="token punctuation">;</span> <span class="token comment">//*ptr 的结果是 ptr 所指向的东西，在这里是一个指针，</span>
	<span class="token comment">//对这个指针再做一次*运算，结果是一个int类型的变量。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="_04-指针表达式『重要，还有左值』"><a href="#_04-指针表达式『重要，还有左值』" class="header-anchor">#</a> 04.指针表达式『重要，还有左值』</h2> <ul><li><font style="background:yellow;">一个<strong>表达式的结果</strong>如果是一个指针，那么这个表达式就叫<strong>指针表达式</strong>。 </font></li></ul> <p>下面是一些指针表达式的例子：</p> <p>例七：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>pa<span class="token punctuation">;</span>
    pa<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span> 			<span class="token comment">//&amp;a 是一个指针表达式。</span>
    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token operator">&amp;</span>pa<span class="token punctuation">;</span>  <span class="token comment">//&amp;pa 也是一个指针表达式。</span>
    <span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span> 		<span class="token comment">//*ptr 和&amp;b 都是指针表达式。</span>
    pa<span class="token operator">=</span>array<span class="token punctuation">;</span>
    pa<span class="token operator">++</span><span class="token punctuation">;</span> 			<span class="token comment">//这也是指针表达式</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>例八：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>    <span class="token keyword">char</span> <span class="token operator">*</span>arr<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>parr<span class="token operator">=</span>arr<span class="token punctuation">;</span> <span class="token comment">//如果把 arr 看作指针的话，arr 也是指针表达式</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">;</span>
    str<span class="token operator">=</span><span class="token operator">*</span>parr<span class="token punctuation">;</span> 		<span class="token comment">//*parr 是指针表达式</span>
    str<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>parr<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//*(parr+1)是指针表达式</span>
    str<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>parr<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//*(parr+2)是指针表达式</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li><p>由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：</p> <ul><li>指针的类型</li> <li>指针所指向的类型</li> <li>指针指向的内存区</li> <li>指针自身占据的内存</li></ul></li> <li><p>好了，<font style="background:yellow;">当一个指针表达式的结果指针<strong>已经明确地具有了指针自身占据的内存</strong>的话，这个指针表达式就是一个<strong>左值</strong>，否则就不是一个左值。</font></p></li> <li><p>在例七中</p></li> <li><p><code>&amp;a</code>不是一个左值，因为它<strong>还没有占据明确的内存</strong>。<font style="background:yellow;">『很重要的，因为a仅仅是声明，没有被定义？？是这个原因吗？我的疑问2021.7HACV』</font></p></li> <li><p><code>*ptr</code>是 一个左值，因为<code>*ptr</code>这个指针已经占据了内存，其实<code>*ptr</code> 就是指针 pa， 既然 <strong>pa 已经在内存中有了自己的位置</strong>，那么<code>*ptr</code>当然也有了自己的位置。</p></li></ul> <h2 id="_05-数组和指针的关系"><a href="#_05-数组和指针的关系" class="header-anchor">#</a> 05.数组和指针的关系</h2> <p>数组的数组名其实可以看作一个指针。看下例：</p> <p>例九：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">,</span>value<span class="token punctuation">;</span>
value<span class="token operator">=</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//也可写成：value=*array;</span>
value<span class="token operator">=</span>array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//也可写成：value=*(array+3);</span>
value<span class="token operator">=</span>array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//也可写成：value=*(array+4);</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>上例中，一般而言数组名 array 代表数组本身，类型是<code>int[10]</code>，但如果把 array 看做指针的话，它指向数组的第0个单元，类型是<code>int*</code>， 所指向的类型是数组单元的类型即<code>int</code>。因此<code>*array</code>等于 0 就一点也不 奇怪了。同理，array+3 是一个指向数组第 3 个单元的指针，所以 <code>*(array+3)</code>等于 3。其它依此类推。</p> <p>例十：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span>
    <span class="token string">&quot;Hello,thisisasample!&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;Hi,goodmorning.&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;Helloworld&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span>；

<span class="token function">strcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//也可写成 strcpy(s,*str);</span>

<span class="token function">strcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//也可写成 strcpy(s,*(str+1));</span>

<span class="token function">strcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//也可写成 strcpy(s,*(str+2));</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针， 这些指针各指向一个字符串。把指针数组名 str 当作一个指针的话，它指向数组的第 0 号单元，它的类型是 <code>char **</code>，它指向的类型是<code>char *</code></p> <p><code>*str</code> 也是一个指针，它的类型是 <code>char *</code>，它所指向的类型是 <code>char</code>，它 指向的地址是字符串<code>&quot;Hello,thisisasample!&quot;</code>的第一个字符的地址，即 'H'的地址。</p> <ul><li>注意:字符串相当于是一个数组,在内存中以数组的形式储 存,只不过字符串是一个数组常量,内容不可改变,且只能是右值.如果看成指针的话,他即是常量指针,也是指针常量</li></ul> <p>str+1也是一个指针，它指向数组的第 1 号单元，它的类型是<code>char**</code>， 它指向的类型是 <code>char*</code>。</p> <p><code>*(str+1)</code>也是一个指针，它的类型是<code>char*</code>，它所指向的类型是 char， 它指向 <code>&quot;Hi,goodmorning.&quot;</code>的第一个字符'H'</p> <p>下面总结一下数组的数组名(数组中储存的也是数组)的问题:</p> <p>声明了一个数组<code>TYPE array[n]</code>，则数组名称 array 就有了两重含义：</p> <ul><li>第一，它代表整个数组，它的类型是<code>TYPE[n]</code>；</li> <li>第二 ，它是一个常量指针，该指针的类型是<code>TYPE*</code>，该指针指向的类型是<code>TYPE</code>，也就是数组单元的类型，该指针指向的内存区就是数组第 0 号单元，该指针自己占 有单独的内存区，注意它和数组第 0 号单元占据的内存区是不同的。该 指针的值是不能修改的，即类似<code>array++</code>的表达式是错误的。</li></ul> <p><font style="background:yellow;">在不同的表达式中数组名 array 可以扮演不同的角色。</font></p> <ul><li>在表达式 sizeof(array)中，数组名 array 代表<strong>数组本身</strong>，故这时 sizeof 函数测出的是整个数组的大小</li> <li>在表达式<code>*array</code>中，array 扮演的是指针，因此这个表达式的结果就是 数组第 0 号单元的值。<code>sizeof(*array)</code>测出的是数组单元的大小。</li> <li>表达式 array+n（其中 n=0，1，2，.....）中，array 扮演的是指 针，故 array+n 的结果是一个指针，它的类型是<code>TYPE *</code>，它指向的类型是 TYPE，它指向数组第 n 号单元。故<code>sizeof(array+n)</code>测出的是指针类型的大小。在 32 位程序中结果是4</li></ul> <p>例十一：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    ptr<span class="token operator">=</span><span class="token operator">&amp;</span>array<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上例中 ptr 是一个指针，它的类型是<code>int(*)[10]</code>，他指向的类型是 int[10]</p> <ul><li><p>我们用整个数组的首地址来初始化它。在语句 ptr=&amp;array 中，array 代表<strong>数组本身</strong>。</p></li> <li><p>本节中提到了函数 sizeof()，那么我来问一问，<font style="background:yellow;"><code>sizeof(指针名称)</code>测出的究竟是<strong>指针自身类型的大小</strong>呢还是指针所指向的类型的大小？ 答案是<strong>前者</strong>。</font></p></li></ul> <p>例如</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
则在 <span class="token number">32</span> 位程序中，有：
<span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">4</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">40</span><span class="token function">sizeof</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">4</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><font style="background:yellow;">实际上，<code>sizeof(对象)</code>测出的都是<strong>对象自身的类型的大小</strong>，而不是别的什么类型的大小。『让我联想到了C++中sizeof引用的假象！！』</font></p> <h2 id="_06-指针和结构类型的关系"><a href="#_06-指针和结构类型的关系" class="header-anchor">#</a> 06.指针和结构类型的关系</h2> <ul><li>可以声明一个指向结构类型对象的指针。</li></ul> <p>例12：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">MyStruct</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">MyStruct</span> ss<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">//声明了结构对象 ss，并把 ss 的成员初始化为 20，30 和 40。</span>

<span class="token keyword">struct</span> <span class="token class-name">MyStruct</span> <span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token operator">&amp;</span>ss<span class="token punctuation">;</span>
	<span class="token comment">//声明了一个指向结构对象 ss 的指针。它的类型是</span>
	<span class="token comment">//MyStruct *,它指向的类型是 MyStruct。</span>

<span class="token keyword">int</span> <span class="token operator">*</span>pstr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ss<span class="token punctuation">;</span>
	<span class="token comment">//声明了一个指向结构对象 ss 的指针。但是 pstr 和</span>
	<span class="token comment">//它被指向的类型 ptr 是不同的。</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>请问怎样通过指针 ptr 来访问 ss 的三个成员变量？</p> <ul><li>答案：</li></ul> <div class="language-c line-numbers-mode"><pre class="language-c"><code>
ptr<span class="token operator">-&gt;</span>a<span class="token punctuation">;</span> <span class="token comment">//指向运算符，或者可以这们(*ptr).a,建议使用前者</span>
ptr<span class="token operator">-&gt;</span>b<span class="token punctuation">;</span>
ptr<span class="token operator">-&gt;</span>c<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>又请问怎样通过指针 pstr 来访问 ss 的三个成员变量？
答案：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token operator">*</span>pstr； <span class="token comment">//访问了 ss 的成员 a。</span>
<span class="token operator">*</span><span class="token punctuation">(</span>pstr<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//访问了 ss 的成员 b。</span>
<span class="token operator">*</span><span class="token punctuation">(</span>pstr<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">//访问了 ss 的成员 c。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>虽然我在我的<code>MSVC++6.0</code>上调式过上述代码，但是要知道，这样使用 pstr 来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元: (将结构体换成数组)</p> <p>例13：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">35</span><span class="token punctuation">,</span><span class="token number">56</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pa<span class="token operator">=</span>array<span class="token punctuation">;</span>
通过指针 pa 访问数组 array 的三个单元的方法是：
<span class="token operator">*</span>pa<span class="token punctuation">;</span> <span class="token comment">//访问了第 0 号单元</span>
<span class="token operator">*</span><span class="token punctuation">(</span>pa<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//访问了第 1 号单元</span>
<span class="token operator">*</span><span class="token punctuation">(</span>pa<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//访问了第 2 号单元</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。</p> <p>所有的 C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。</p> <ul><li><font style="background:yellow;">但在存放结构对象的各个成员时，在某种<strong>编译环境</strong>下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个&quot;<strong>填充字节</strong>&quot;，这就导致各个成员之间可能会有若干个字节的空隙。</font></li></ul> <p>所以，在例十二中，即使<code>*pstr</code>访问到了结构对象 ss 的第一个成 员变量 a，也不能保证<code>*(pstr+1)</code>就一定能访问到结构成员 b。因为成员 a 和成员 b 之间可能会有若干填充字节，说不定<code>*(pstr+1)</code>就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想 看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。 不过指针访问结构成员的正确方法应该是象例十二中使用指针 ptr 的方法。</p> <h2 id="_07-指针和函数的关系ok"><a href="#_07-指针和函数的关系ok" class="header-anchor">#</a> 07.指针和函数的关系OK</h2> <ul><li>可以把一个指针声明成为一个指向函数的指针。</li></ul> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pfun1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pfun1<span class="token operator">=</span>fun1<span class="token punctuation">;</span>
<span class="token keyword">int</span> a<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>pfun1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">&quot;abcdefg&quot;</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">//通过函数指针调用函数。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</li></ul> <p>例14：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">&quot;abcdefghijklmn&quot;</span><span class="token punctuation">;</span>
a<span class="token operator">=</span><span class="token function">fun</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        num<span class="token operator">+=</span><span class="token operator">*</span>s<span class="token punctuation">;</span>	s<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这个例子中的函数fun统计一个字符串中各个字符的ASCII码值之和。</p> <p>前面说了，数组的名字也是一个指针。在函数调用中，当把 str 作为实参传递给形参 s 后，实际是把 str 的值传递给了 s，s 所指向的 地址就和 str 所指向的地址一致，但是 str 和 s 各自占用各自的存储空 间。在函数体内对 s 进行自加 1 运算，并不意味着同时对 str 进行了自加1运算。</p> <h2 id="_08-指针类型转换"><a href="#_08-指针类型转换" class="header-anchor">#</a> 08.指针类型转换</h2> <ul><li><font style="background:yellow;">当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的<strong>右边</strong>是一个<strong>指针表达式</strong>。</font></li> <li>在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的 类型和指针表达式所指向的类型是一样的。</li></ul> <p>例15：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">float</span> f<span class="token operator">=</span><span class="token number">12.3</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> <span class="token operator">*</span>fptr<span class="token operator">=</span><span class="token operator">&amp;</span>f<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上面的例子中，假如我们想让指针 p 指向实数 f，应该怎么办？
是用下面的语句吗？
<code>p=&amp;f;</code></p> <ul><li>不对。因为指针 p 的类型是<code>int *</code>，它指向的类型是 int。表达式</li></ul> <p><code>&amp;f</code>的结果是一个指针，指针的类型是<code>float *</code>,它指向的类型是 float。</p> <p>两者不一致，直接赋值的方法是不行的。至少在我的 <strong>MSVC++6.0</strong> 上，对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致，其它的编译器上我没试过，大家可以试试。为了实现我们的目的，需要进行&quot;<strong>强制类型转换</strong>&quot;：
<code>p=(int*)&amp;f;</code></p> <p>如果有一个指针 p，我们需要把它的类型和所指向的类型改为</p> <p><code>TYEP *TYPE，那么语法格式是：(TYPE *)p;</code>
这样强制类型转换的结果是一个新指针，该新指针的类型是<code>TYPE *</code>，它指向的类型是 TYPE，它指向的地址就是原指针指向的地址。 而<font style="background:yellow;">原来的指针 p 的一切属性都没有被修改。（切记）</font></p> <ul><li>一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，<strong>必须保证类型一致 ，否则需要强制转换</strong></li></ul> <p>例16：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">125</span><span class="token punctuation">,</span>b<span class="token punctuation">;</span>
<span class="token function">fun</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    charc<span class="token punctuation">;</span>
    c<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">=</span>c<span class="token punctuation">;</span>
    c<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span>c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>注意这是一个 32 位程序，故 int 类型占了四个字节，char 类型占一个字节。函数 fun 的作用是把一个整数的四个字节的顺序来个颠倒。</p> <p>注意到了吗？在函数调用语句中，实参&amp;a 的结果是一个指针，它的类型是<code>int *</code>，它指向的类型是 int。形参这个指针的类型是<code>char *</code>，它指向的类型是 char。这样，在实参和形参的结合过程中，我们必须进行一次从<code>int *</code>类型到<code>char *</code>类型的转换。结合这个例子，我们可以这样来想象编译器进行转换的过程：编译器先构造一个临时指针<code>char *temp</code>，然后执行<code>temp=(char *)&amp;a</code>，最后再把 temp 的值传递给 s。</p> <p>所以最后的结果是：s 的类型是<code>char *</code>,它指向的类型是 char，它指向的地址就是a 的首地址。</p> <ul><li>我们已经知道，指针的值就是指针指向的地址，在 32 位程序中， 指针的值其实是一个 32 位整数。<font style="background:yellow;">那可不可以把一个整数当作指针的值 直接赋给指针呢？</font>就象下面的语句：</li></ul> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
TYPE <span class="token operator">*</span>ptr<span class="token punctuation">;</span> 		<span class="token comment">//TYPE 是 int，char 或结构类型等等类型。</span>
a<span class="token operator">=</span><span class="token number">20345686</span><span class="token punctuation">;</span>
ptr<span class="token operator">=</span><span class="token number">20345686</span><span class="token punctuation">;</span> 	<span class="token comment">//我们的目的是要使指针 ptr 指向地址 20345686</span>
ptr<span class="token operator">=</span>a<span class="token punctuation">;</span> 			<span class="token comment">//我们的目的是要使指针 ptr 指向地址 20345686</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><p>编译一下吧。结果发现后面两条语句全是错的。</p></li> <li><p>那么我们的目的就不能达到了吗？不，还有办法：</p></li></ul> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
TYPE <span class="token operator">*</span>ptr<span class="token punctuation">;</span> 		<span class="token comment">//TYPE 是 int，char 或结构类型等等类型。</span>
a<span class="token operator">=</span>N 			<span class="token comment">//N 必须代表一个合法的地址；</span>
ptr<span class="token operator">=</span><span class="token punctuation">(</span>TYPE<span class="token operator">*</span><span class="token punctuation">)</span>a； 	<span class="token comment">//呵呵，这就可以了。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>严格说来这里的<code>(TYPE *)</code>和指针类型转换中的<code>(TYPE *)</code>还不一样。</p> <ul><li>这里的<code>(TYPE*)</code>的意思是把<strong>无符号整数</strong> a 的值当作一个地址来看待。上面强 调了 a 的值必须代表一个合法的地址，否则的话，在你使用<code>ptr</code>的时候， 就会出现非法操作错误。</li> <li>想想能不能反过来，把指针指向的地址即指针的值当作一个整数出来。完全可以。下面的例子演示了把一个指针的值当作一个整数取出 来，然后再把这个整数当作一个地址赋给一个指针：</li></ul> <p>例17：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">,</span>b<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">;</span>
b<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ptr<span class="token punctuation">;</span> 	<span class="token comment">//把指针 ptr 的值当作一个整数取出来。</span>
str<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span> 	<span class="token comment">//把这个整数的值当作一个地址赋给指针 str。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针。</li></ul> <h2 id="_09-指针的安全问题"><a href="#_09-指针的安全问题" class="header-anchor">#</a> 09.指针的安全问题</h2> <p>看下面的例子：</p> <p>例十八：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>    <span class="token keyword">char</span> s<span class="token operator">=</span><span class="token string">'a'</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
    ptr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>s<span class="token punctuation">;</span>
    <span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token number">1298</span>；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>指针 ptr 是一个<code>int *</code>类型的指针，它指向的类型是 int。它指向的地址就是 s 的首地址。在 32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了 s 所占的一个字节，还把和 s 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。<br>
让我们再来看一例：</p> <p><strong>例19：</strong></p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>    <span class="token keyword">char</span> a<span class="token punctuation">;</span>	
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    ptr<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token number">115</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	该例子完全可以通过编译，并能执行。但是看到没有？第 3 句对指针 ptr 进行自加 1 运算后，ptr 指向了和整形变量 a 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非 常重要的数据，甚至可能是一条代码。而第 4 句竟然往这片存储区里写 入一个数据！这是严重的错误。</p> <ul><li>所以<strong>在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里</strong>。在用指针访问数组的时候，也要注 意不要超出数组的低端和高端界限，否则也会造成类似的错误</li> <li>在指针的<strong>强制类型转换</strong>：<code>ptr1=(TYPE *)ptr2</code>中
<ul><li>如果<code>sizeof(ptr2 的类型)大于 sizeof(ptr1 的类型)</code>，那么在使用指针 ptr1 来访问 ptr2 所 指 向 的 存 储 区时是 <strong>安 全</strong> 的 。 <font style="background:yellow;">『HACV，觉得不仅仅是&gt;而是&gt;=』</font></li> <li>如果<code>sizeof(ptr2 的 类 型 ) 小 于 sizeof(ptr1 的类型)</code>，那么在使用指针 ptr1 来访问 ptr2 所指向的存储区时是<strong>不安全的</strong>。</li> <li>至于为什么，读者结合例十八来想一想，应该会明白的。</li></ul></li></ul> <h2 id="_10-结束语"><a href="#_10-结束语" class="header-anchor">#</a> 10.结束语</h2> <ul><li>各位，现在你是否已经觉得指针再也不是你所想的那么难了</li> <li>如果你的回答是：对，不难！哈哈，恭喜你，你已经掌握 C 语言的精华了，C中唯一的难点就是指针，指针搞定其它小菜而已，重要的是实践。</li> <li>唉，已经到了该说再见的时候了，祝各位在C语言的学习中一帆风顺，让我们一起用语言来谱写我们的人生吧！</li></ul></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.8446f194.js" defer></script><script src="/assets/js/83.125aa7a6.js" defer></script>
  </body>
</html>
